{"title":"简单的水果分类识别","uid":"3c9c3f4226248e23e6c72e4ac83d74c5","slug":"水果分类识别","date":"2024-09-06T13:41:30.558Z","updated":"2024-09-11T13:29:24.190Z","comments":true,"path":"api/articles/水果分类识别.json","keywords":null,"cover":"https://images.pexels.com/photos/68525/soap-colorful-color-fruit-68525.jpeg?cs=srgb&dl=pexels-pixabay-68525.jpg&fm=jpg","content":"<h1 id=\"任务一：水果分类识别\"><a href=\"#任务一：水果分类识别\" class=\"headerlink\" title=\"任务一：水果分类识别\"></a>任务一：水果分类识别</h1><p>​\t首先我先描述一下我的大体实现思路：</p>\n<h2 id=\"整体思路流程\"><a href=\"#整体思路流程\" class=\"headerlink\" title=\"整体思路流程\"></a>整体思路流程</h2><ol>\n<li><p><strong>特征提取</strong>：从图像中提取两类特征（边界特征和纹理特征），用于描述水果的形状和表面纹理。</p>\n</li>\n<li><p><strong>数据处理</strong>：读取数据目录中的图像，提取特征并准备数据集。</p>\n</li>\n<li><p><strong>模型训练</strong>：使用提取的特征数据训练一个逻辑回归模型，并保存为一个模型文件以待调用。</p>\n</li>\n<li><p><strong>单个图像预测</strong>：使用训练好的模型对单个图像进行预测，并输出预测结果。</p>\n</li>\n</ol>\n<div class=\"custom-quote warning\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 15.99V16.01\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">WARNING</p>\n<p>其中边界特征利用Canny算法提取，然后在图像内部划分子区域进行纹理特征提取，最后特征向量都要归一化处理。\n</div>\n<h2 id=\"1-1-特征提取之边界特征提取\"><a href=\"#1-1-特征提取之边界特征提取\" class=\"headerlink\" title=\"1.1 特征提取之边界特征提取\"></a>1.1 特征提取之边界特征提取</h2><p>​\t通过搜寻相关资料，利用canny进行提取边缘的步骤如下(参考下方代码)：</p>\n<p><strong>1.灰度转换：</strong>将输入的彩色图像转换为灰度图像。<br><strong>2.高斯模糊：</strong>对灰度图像进行高斯模糊处理以减少噪声。<br><strong>3.Canny 边缘检测：</strong>使用 Canny 算法提取图像的边缘。<br><strong>4.轮廓检测：</strong>找到图像中的所有轮廓。<br><strong>5.计算线段长度：</strong>遍历每个轮廓，计算任意两点之间的距离。</p>\n<p><strong>6. 划分区间：</strong>划分十个区间统计各个区间线段数量</p>\n<p><strong>7.归一化特征：</strong>对所有线段长度进行归一化处理。</p>\n<p><img src=\"/images/apple.png\" alt=\"apple\"></p>\n<details class=\"custom-details\">\n<summary>点击这里查看边界特征提取代码</summary>\n<p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 边界特征提取函数</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">extract_shape_features</span>(<span class=\"params\">image</span>):</span><br><span class=\"line\">    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)</span><br><span class=\"line\">    blurred = cv2.GaussianBlur(gray, (<span class=\"number\">5</span>, <span class=\"number\">5</span>), <span class=\"number\">0</span>)</span><br><span class=\"line\">    edges = cv2.Canny(blurred, <span class=\"number\">50</span>, <span class=\"number\">150</span>)</span><br><span class=\"line\">    contours, _ = cv2.findContours(edges, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)</span><br><span class=\"line\"></span><br><span class=\"line\">    all_distances = []</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> contour <span class=\"keyword\">in</span> contours:</span><br><span class=\"line\">        num_points = <span class=\"built_in\">len</span>(contour)</span><br><span class=\"line\">        distances = []</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(num_points):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(i + <span class=\"number\">1</span>, num_points):</span><br><span class=\"line\">                distance = cv2.norm(contour[i] - contour[j])</span><br><span class=\"line\">                distances.append(distance)</span><br><span class=\"line\"></span><br><span class=\"line\">        all_distances.extend(distances)</span><br><span class=\"line\"></span><br><span class=\"line\">    all_distances = np.array(all_distances)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> all_distances.size == <span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> np.zeros(<span class=\"number\">10</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    bins = [<span class=\"number\">0</span>, <span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>, <span class=\"number\">40</span>, <span class=\"number\">50</span>, <span class=\"number\">60</span>, <span class=\"number\">70</span>, <span class=\"number\">80</span>, <span class=\"number\">90</span>, <span class=\"number\">100</span>]</span><br><span class=\"line\">    histogram, _ = np.histogram(all_distances, bins=bins)</span><br><span class=\"line\">    feature_vector = histogram / np.<span class=\"built_in\">sum</span>(histogram)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> feature_vector</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</p>\n</details>\n<h2 id=\"1-2-特征提取之纹理特征提取\"><a href=\"#1-2-特征提取之纹理特征提取\" class=\"headerlink\" title=\"1.2 特征提取之纹理特征提取\"></a>1.2 特征提取之纹理特征提取</h2><p>经查询相关资料，纹理特征提取步骤如下（参考下面代码）：</p>\n<ol>\n<li><strong>灰度转换：</strong>将输入的彩色图像转换为灰度图像。</li>\n<li><strong>分割图像：</strong>将图像分割成四个子区域。</li>\n<li><strong>提取子区域特征：</strong>对每个子区域计算均值和标准差。</li>\n<li><strong>归一化特征向量：</strong>将特征向量归一化。</li>\n<li><strong>返回特征向量：</strong>返回最终的纹理特征向量。</li>\n</ol>\n<details class=\"custom-details\">\n<summary>点击这里查看纹理特征提取代码</summary>\n<p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">extract_texture_features</span>(<span class=\"params\">image, num_regions=<span class=\"number\">4</span></span>):</span><br><span class=\"line\">    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)</span><br><span class=\"line\">    h, w = gray.shape</span><br><span class=\"line\"></span><br><span class=\"line\">    region_height = h // <span class=\"number\">2</span></span><br><span class=\"line\">    region_width = w // <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\">    texture_features = []</span><br><span class=\"line\"></span><br><span class=\"line\">    regions = [</span><br><span class=\"line\">        (<span class=\"number\">0</span>, <span class=\"number\">0</span>, region_height, region_width),</span><br><span class=\"line\">        (<span class=\"number\">0</span>, region_width, region_height, w),</span><br><span class=\"line\">        (region_height, <span class=\"number\">0</span>, h, region_width),</span><br><span class=\"line\">        (region_height, region_width, h, w)</span><br><span class=\"line\">    ]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (y_start, x_start, y_end, x_end) <span class=\"keyword\">in</span> regions:</span><br><span class=\"line\">        roi = gray[y_start:y_end, x_start:x_end]</span><br><span class=\"line\">        mean = np.mean(roi)</span><br><span class=\"line\">        std_dev = np.std(roi)</span><br><span class=\"line\">        texture_features.extend([mean, std_dev])</span><br><span class=\"line\"></span><br><span class=\"line\">    texture_features = np.array(texture_features)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> np.linalg.norm(texture_features) &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">        texture_features = texture_features / np.linalg.norm(texture_features)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> texture_features</span><br></pre></td></tr></table></figure>\n</p>\n</details>\n<h2 id=\"2-数据处理\"><a href=\"#2-数据处理\" class=\"headerlink\" title=\"2 数据处理\"></a>2 数据处理</h2><p>​\t训练的数据集大部分来自百度飞桨的公开数据库，参考链接：<a href=\"https://aistudio.baidu.com/datasetdetail/90377%EF%BC%8C\">https://aistudio.baidu.com/datasetdetail/90377，</a></p>\n<p>​\t还有部分来自谷歌图片上手动下载保存，为了确保特征提取准确、模型预测更精准，我删除了大量较复杂的图片，只保留了简单的、具有单个水果、特征明显的图片，因此最后的图片数量不多。</p>\n<p>​\t为了使数据多样化、尽可能避免过拟合现象，我搜寻了一些简单的数据增强的方法，基于现有的图片数据增生了一些图片。如下面图片既包括搜集到的数据，也包括增生的数据。</p>\n<p><img src=\"/images/1.png\"></p>\n<p>准备完了数据，我们开始利用之前的方法提取特征：</p>\n<ol>\n<li><strong>路径和标签初始化：</strong>初始化两个列表 image_paths 和 labels 用于存储图像路径和标签。</li>\n<li><strong>标签映射：</strong>定义一个字典 label_map 将水果类型映射为整数标签。</li>\n<li><strong>读取图像并提取特征：</strong>读取每张图像，提取形状特征和纹理特征，并将它们合并为一个特征向量。</li>\n<li><strong>返回特征矩阵和标签数组：</strong>将特征列表转换为 NumPy 数组，并返回特征矩阵和标签数组。</li>\n</ol>\n<details class=\"custom-details\">\n<summary>点击这里查看数据处理部分的代码</summary>\n<p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 数据准备</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">prepare_data</span>(<span class=\"params\">base_dir</span>):</span><br><span class=\"line\">    image_paths = []</span><br><span class=\"line\">    labels = []</span><br><span class=\"line\">    label_map = &#123;<span class=\"string\">&#x27;apple&#x27;</span>: <span class=\"number\">0</span>, <span class=\"string\">&#x27;banana&#x27;</span>: <span class=\"number\">1</span>, <span class=\"string\">&#x27;orange&#x27;</span>: <span class=\"number\">2</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> fruit_type, label <span class=\"keyword\">in</span> label_map.items():</span><br><span class=\"line\">        fruit_dir = os.path.join(base_dir, fruit_type)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> os.path.isdir(fruit_dir):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> filename <span class=\"keyword\">in</span> os.listdir(fruit_dir):</span><br><span class=\"line\">                <span class=\"keyword\">if</span> filename.lower().endswith((<span class=\"string\">&#x27;.png&#x27;</span>, <span class=\"string\">&#x27;.jpg&#x27;</span>, <span class=\"string\">&#x27;.jpeg&#x27;</span>)):</span><br><span class=\"line\">                    image_paths.append(os.path.join(fruit_dir, filename))</span><br><span class=\"line\">                    labels.append(label)</span><br><span class=\"line\"></span><br><span class=\"line\">    X = []</span><br><span class=\"line\">    y = np.array(labels)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> path <span class=\"keyword\">in</span> image_paths:</span><br><span class=\"line\">        image = cv2.imread(path)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> image <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;警告：无法读取图像 <span class=\"subst\">&#123;path&#125;</span>，请检查文件路径。&quot;</span>)</span><br><span class=\"line\">            <span class=\"keyword\">continue</span></span><br><span class=\"line\">        shape_features = extract_shape_features(image)</span><br><span class=\"line\">        texture_features = extract_texture_features(image)</span><br><span class=\"line\">        features = np.hstack((shape_features, texture_features))</span><br><span class=\"line\">        X.append(features)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> np.array(X), y</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 使用 JPEGImages 目录进行数据准备</span></span><br><span class=\"line\">base_dir = <span class=\"string\">&#x27;JPEGImages&#x27;</span></span><br><span class=\"line\">X, y = prepare_data(base_dir)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 归一化特征</span></span><br><span class=\"line\">scaler = StandardScaler()</span><br><span class=\"line\">X = scaler.fit_transform(X)</span><br></pre></td></tr></table></figure>\n\n</p>\n</details>\n<h2 id=\"3-模型训练\"><a href=\"#3-模型训练\" class=\"headerlink\" title=\"3 模型训练\"></a>3 模型训练</h2><p>模型训练大致分以下几步：</p>\n<ol>\n<li><p><strong>数据划分：</strong>将数据划分为80%训练集和20%测试集，以确保模型在未知数据上的泛化能力。</p>\n</li>\n<li><p><strong>模型创建和训练：</strong>创建逻辑回归模型，并使用训练集进行训练。</p>\n</li>\n<li><p><strong>模型预测：</strong>使用训练好的模型对测试集进行预测，得到预测标签。</p>\n</li>\n<li><p><strong>模型评估：</strong>计算预测标签与真实标签之间的准确率、精度、召回率，评估模型性能。</p>\n</li>\n</ol>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>（经检验运行后发现模型效果非常理想，这和我删除了大量较复杂的图片，只保留了简单的、具有单个水果、特征明显的图片有较大关系）</p></blockquote>\n<p><img src=\"/images/model.png\" alt=\"model\"></p>\n<details class=\"custom-details\">\n<summary>点击这里查看上述步骤的代码</summary>\n<p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 划分训练集和测试集</span></span><br><span class=\"line\">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=<span class=\"number\">0.2</span>, random_state=<span class=\"number\">42</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建逻辑回归模型并训练</span></span><br><span class=\"line\">model = LogisticRegression(max_iter=<span class=\"number\">1000</span>)</span><br><span class=\"line\">model.fit(X_train, y_train)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 保存模型和标准化器</span></span><br><span class=\"line\">model_filename = <span class=\"string\">&#x27;model.pkl&#x27;</span></span><br><span class=\"line\">scaler_filename = <span class=\"string\">&#x27;scaler.pkl&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">joblib.dump(model, model_filename)</span><br><span class=\"line\">joblib.dump(scaler, scaler_filename)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 计算准确率</span></span><br><span class=\"line\">y_pred = model.predict(X_test)</span><br><span class=\"line\">accuracy = accuracy_score(y_test, y_pred)</span><br><span class=\"line\">precision = precision_score(y_test, y_pred, average=<span class=\"string\">&#x27;weighted&#x27;</span>)</span><br><span class=\"line\">recall = recall_score(y_test, y_pred, average=<span class=\"string\">&#x27;weighted&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;模型准确率: <span class=\"subst\">&#123;accuracy:<span class=\"number\">.2</span>f&#125;</span>&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;模型精度: <span class=\"subst\">&#123;precision:<span class=\"number\">.2</span>f&#125;</span>&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;模型召回率: <span class=\"subst\">&#123;recall:<span class=\"number\">.2</span>f&#125;</span>&quot;</span>)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n</p>\n</details>\n<h2 id=\"4-单个图像预测\"><a href=\"#4-单个图像预测\" class=\"headerlink\" title=\"4 单个图像预测\"></a>4 单个图像预测</h2><p>最后我们可以利用之前训练好的模型进行图片预测,可以将其封装成一个函数，函数实现步骤如下：</p>\n<ol>\n<li>读取图像：使用 cv2.imread 读取待测试的图像。</li>\n<li>特征提取：提取图像的形状特征和纹理特征。</li>\n<li>合并特征：将形状特征和纹理特征合并为一个特征向量，并重塑为 (1, -1) 形状。</li>\n<li>特征缩放：使用预先训练好的 scaler 对特征进行缩放处理。</li>\n<li>模型预测：使用训练好的模型对缩放后的特征进行预测。</li>\n</ol>\n<details class=\"custom-details\">\n<summary>点击这里查看预测示例</summary>\n<p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> cv2</span><br><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"keyword\">import</span> joblib</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> fruits.categorize <span class=\"keyword\">import</span> extract_shape_features, extract_texture_features</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 加载模型和标准化器</span></span><br><span class=\"line\">model_filename = <span class=\"string\">&#x27;model.pkl&#x27;</span></span><br><span class=\"line\">scaler_filename = <span class=\"string\">&#x27;scaler.pkl&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">model = joblib.load(model_filename)</span><br><span class=\"line\">scaler = joblib.load(scaler_filename)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 单个图像分类示例</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">predict_image</span>(<span class=\"params\">image_path</span>):</span><br><span class=\"line\">    image = cv2.imread(image_path)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> image <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;无法读取图像 <span class=\"subst\">&#123;image_path&#125;</span>，请检查路径。&quot;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">None</span></span><br><span class=\"line\"></span><br><span class=\"line\">    shape_features = extract_shape_features(image)</span><br><span class=\"line\">    texture_features = extract_texture_features(image)</span><br><span class=\"line\">    features = np.hstack((shape_features, texture_features)).reshape(<span class=\"number\">1</span>, -<span class=\"number\">1</span>)</span><br><span class=\"line\">    features = scaler.transform(features)</span><br><span class=\"line\">    prediction = model.predict(features)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> prediction[<span class=\"number\">0</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 使用模型预测水果类型</span></span><br><span class=\"line\">test_image_path = <span class=\"string\">&#x27;JPEGImages/banana/banana1.jpg&#x27;</span>  <span class=\"comment\"># 替换为测试水果图像路径</span></span><br><span class=\"line\">predicted_label = predict_image(test_image_path)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> predicted_label <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">    label_map_inverse = &#123;<span class=\"number\">0</span>: <span class=\"string\">&#x27;苹果&#x27;</span>, <span class=\"number\">1</span>: <span class=\"string\">&#x27;香蕉&#x27;</span>, <span class=\"number\">2</span>: <span class=\"string\">&#x27;橙子&#x27;</span>&#125;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;这个水果应该是: <span class=\"subst\">&#123;label_map_inverse.get(predicted_label, <span class=\"string\">&#x27;无法识别的水果&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n</p>\n</details>\n<p>最后将要测试的图片的路径修改入代码之中，运行之后即可看到预测的结果，结果如下</p>\n<p><img src=\"/images/success.png\" alt=\"success\"></p>\n<h2 id=\"5-完结撒花\"><a href=\"#5-完结撒花\" class=\"headerlink\" title=\"5 完结撒花\"></a>5 完结撒花</h2><p><img src=\"https://dl4.weshineapp.com/gif/20170106/73b69e674e3781f9ec7470619be78ef4.gif?f=micro_5bqG56Wd\" alt=\"img\"></p>\n","feature":true,"text":"任务一：水果分类识别​ 首先我先描述一下我的大体实现思路： 整体思路流程 特征提取：从图像中提取两类特征（边界特征和纹理特征），用于描述水果的形状和表面纹理。 ...","permalink":"/post/水果分类识别","photos":[],"count_time":{"symbolsCount":"6.6k","symbolsTime":"6 mins."},"categories":[{"name":"机器学习","slug":"机器学习","count":1,"path":"api/categories/机器学习.json"}],"tags":[{"name":"水果分类","slug":"水果分类","count":2,"path":"api/tags/水果分类.json"},{"name":"计算机视觉","slug":"计算机视觉","count":2,"path":"api/tags/计算机视觉.json"},{"name":"逻辑回归","slug":"逻辑回归","count":1,"path":"api/tags/逻辑回归.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BB%BB%E5%8A%A1%E4%B8%80%EF%BC%9A%E6%B0%B4%E6%9E%9C%E5%88%86%E7%B1%BB%E8%AF%86%E5%88%AB\"><span class=\"toc-text\">任务一：水果分类识别</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%95%B4%E4%BD%93%E6%80%9D%E8%B7%AF%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">整体思路流程</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-1-%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96%E4%B9%8B%E8%BE%B9%E7%95%8C%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96\"><span class=\"toc-text\">1.1 特征提取之边界特征提取</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-2-%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96%E4%B9%8B%E7%BA%B9%E7%90%86%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96\"><span class=\"toc-text\">1.2 特征提取之纹理特征提取</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86\"><span class=\"toc-text\">2 数据处理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83\"><span class=\"toc-text\">3 模型训练</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-%E5%8D%95%E4%B8%AA%E5%9B%BE%E5%83%8F%E9%A2%84%E6%B5%8B\"><span class=\"toc-text\">4 单个图像预测</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-%E5%AE%8C%E7%BB%93%E6%92%92%E8%8A%B1\"><span class=\"toc-text\">5 完结撒花</span></a></li></ol></li></ol>","author":{"name":"神秘奇男子","slug":"blog-author","avatar":"https://i.ibb.co/b3C0QpT/584-2022101195826670.jpg","link":"/","description":"但凡我有一点办法，我都不至于一点办法没有","socials":{"github":"https://github.com/August618?tab=repositories","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/august121wsy","csdn":"https://blog.csdn.net/UPCAUG?spm=1011.2124.3001.5343","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/1931947622/favlist?fid=1765359122"},"Gitee":{"icon":"/svg/gitee.svg","link":"https://gitee.com/wu-shanyu-AUG"}}}},"mapped":true,"hidden":false,"prev_post":{"title":"Git的简单归纳","uid":"b7eae51efb7dc6d81a7837b0d6a16f52","slug":"Git简介","date":"2024-09-09T13:29:06.476Z","updated":"2024-09-09T14:24:05.228Z","comments":true,"path":"api/articles/Git简介.json","keywords":null,"cover":"https://datascientest.com/en/files/2024/03/GIT-datascientest.jpg","text":"Git的简单归纳 内容修改自github博主arkingc，持续修改补充中 一.git配置 1.配置git用户名和邮箱 二.仓库 1.创建git仓库 2.查看仓...","permalink":"/post/Git简介","photos":[],"count_time":{"symbolsCount":"6.5k","symbolsTime":"6 mins."},"categories":[{"name":"Git","slug":"Git","count":1,"path":"api/categories/Git.json"}],"tags":[{"name":"git简介","slug":"git简介","count":1,"path":"api/tags/git简介.json"},{"name":"git简单使用","slug":"git简单使用","count":1,"path":"api/tags/git简单使用.json"}],"author":{"name":"神秘奇男子","slug":"blog-author","avatar":"https://i.ibb.co/b3C0QpT/584-2022101195826670.jpg","link":"/","description":"但凡我有一点办法，我都不至于一点办法没有","socials":{"github":"https://github.com/August618?tab=repositories","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/august121wsy","csdn":"https://blog.csdn.net/UPCAUG?spm=1011.2124.3001.5343","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/1931947622/favlist?fid=1765359122"},"Gitee":{"icon":"/svg/gitee.svg","link":"https://gitee.com/wu-shanyu-AUG"}}}},"feature":true},"next_post":{"title":"Haar 特征分类器实现人脸识别","uid":"dc76bdb116b22b7d8e614c5e499a6c3f","slug":"基于OpenCV 的 Haar 特征分类器实现人脸检测与显示","date":"2024-08-24T06:37:38.807Z","updated":"2024-09-20T12:18:53.846Z","comments":true,"path":"api/articles/基于OpenCV 的 Haar 特征分类器实现人脸检测与显示.json","keywords":null,"cover":"https://ogre.natalie.mu/media/news/music/2024/0306/ILLIT0306_all1.jpg?impolicy=twitter_card_face_crop","text":"基于OpenCV 的 Haar 特征分类器实现人脸检测与显示在计算机视觉领域，人脸检测是非常基础而且常用的技术，最近刚好在学计算机视觉的相关知识，学到人脸识别时...","permalink":"/post/基于OpenCV 的 Haar 特征分类器实现人脸检测与显示","photos":[],"count_time":{"symbolsCount":"1.8k","symbolsTime":"2 mins."},"categories":[{"name":"计算机视觉","slug":"计算机视觉","count":3,"path":"api/categories/计算机视觉.json"}],"tags":[{"name":"OpenCV","slug":"OpenCV","count":1,"path":"api/tags/OpenCV.json"},{"name":"人脸识别","slug":"人脸识别","count":1,"path":"api/tags/人脸识别.json"}],"author":{"name":"神秘奇男子","slug":"blog-author","avatar":"https://i.ibb.co/b3C0QpT/584-2022101195826670.jpg","link":"/","description":"但凡我有一点办法，我都不至于一点办法没有","socials":{"github":"https://github.com/August618?tab=repositories","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/august121wsy","csdn":"https://blog.csdn.net/UPCAUG?spm=1011.2124.3001.5343","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/1931947622/favlist?fid=1765359122"},"Gitee":{"icon":"/svg/gitee.svg","link":"https://gitee.com/wu-shanyu-AUG"}}}},"feature":true}}