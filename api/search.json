[{"id":"3c9c3f4226248e23e6c72e4ac83d74c5","title":"简单的水果分类识别","content":"任务一：水果分类识别​\t首先我先描述一下我的大体实现思路：\n整体思路流程\n特征提取：从图像中提取两类特征（边界特征和纹理特征），用于描述水果的形状和表面纹理。\n\n数据处理：读取数据目录中的图像，提取特征并准备数据集。\n\n模型训练：使用提取的特征数据训练一个逻辑回归模型。\n\n单个图像预测：使用训练好的模型对单个图像进行预测，并输出预测结果。\n\n\n\n\n\n\n\n\n\nWARNING\n其中边界特征利用Canny算法提取，然后在图像内部选择感兴趣（ROI）区域进行特征提取，最后都要归一化处理。\n\n1.1 特征提取之边界特征提取​\t通过搜寻相关资料，利用canny进行提取边缘的步骤如下(参考下方代码)：\n1.灰度转换：将输入的彩色图像转换为灰度图像。2.高斯模糊：对灰度图像进行高斯模糊处理以减少噪声。3.Canny 边缘检测：使用 Canny 算法提取图像的边缘。4.轮廓检测：找到图像中的所有轮廓。5.计算线段长度：遍历每个轮廓，计算相邻点之间的距离。6.归一化特征：对所有线段长度进行归一化处理。7.截取特征向量：只保留前 10 个特征值。\n\n点击这里查看边界特征提取代码\n123456789101112131415161718def extract_shape_features(image):    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)    blurred = cv2.GaussianBlur(gray, (5, 5), 0)    edges = cv2.Canny(blurred, 50, 150)    contours, _ = cv2.findContours(edges, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)    shape_features = []    for contour in contours:        for i in range(len(contour) - 1):            length = cv2.norm(contour[i] - contour[i + 1])            shape_features.append(length)    shape_features = np.array(shape_features)    if shape_features.size &gt; 0:        shape_features = shape_features / np.linalg.norm(shape_features)    else:        shape_features = np.zeros(10)    return shape_features[:10]\n\n\n1.2 特征提取之纹理特征提取​\t经查询相关资料，纹理特征提取步骤如下（参考下面代码）：\n\n灰度转换：将输入的彩色图像转换为灰度图像。\n确定感兴趣区域（ROI）：在图像中心选取一个较小的区域作为纹理分析的对象。\n计算统计特征：计算选定区域的均值和标准差。\n归一化特征：对计算出的特征向量进行归一化处理。\n\n\n点击这里查看纹理特征提取代码\n12345678910111213def extract_texture_features(image):    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)    h, w = gray.shape    x, y = w // 2, h // 2    roi = gray[max(0, y - 5):min(h, y + 5), max(0, x - 5):min(w, x + 5)]    mean = np.mean(roi)    std_dev = np.std(roi)    texture_features = np.array([mean, std_dev])    if np.linalg.norm(texture_features) &gt; 0:        texture_features = texture_features / np.linalg.norm(texture_features)    return texture_features\n\n\n2 数据处理​\t训练的数据集大部分来自百度飞桨的公开数据库，参考链接：https://aistudio.baidu.com/datasetdetail/90377，\n​\t还有部分来自谷歌图片上手动下载保存，为了确保特征提取准确、模型预测更精准，我删除了大量较复杂的图片，只保留了简单的、具有单个水果、特征明显的图片，因此最后的图片数量不多。\n​\t为了使数据多样化、尽可能避免过拟合现象，我搜寻了一些简单的数据增强的方法，基于现有的图片数据增生了一些图片。如下面图片既包括搜集到的数据，也包括增生的数据。\n\n准备完了数据，我们开始利用之前的方法提取特征：\n\n路径和标签初始化：初始化两个列表 image_paths 和 labels 用于存储图像路径和标签。\n标签映射：定义一个字典 label_map 将水果类型映射为整数标签。\n读取图像并提取特征：读取每张图像，提取形状特征和纹理特征，并将它们合并为一个特征向量。\n返回特征矩阵和标签数组：将特征列表转换为 NumPy 数组，并返回特征矩阵和标签数组。\n\n\n点击这里查看数据处理部分的代码\n123456789101112131415161718192021222324252627282930313233343536# 数据准备def prepare_data(base_dir):    image_paths = []    labels = []    label_map = &#123;&#x27;apple&#x27;: 0, &#x27;banana&#x27;: 1, &#x27;orange&#x27;: 2&#125;    for fruit_type, label in label_map.items():        fruit_dir = os.path.join(base_dir, fruit_type)        if os.path.isdir(fruit_dir):            for filename in os.listdir(fruit_dir):                if filename.lower().endswith((&#x27;.png&#x27;, &#x27;.jpg&#x27;, &#x27;.jpeg&#x27;)):                    image_paths.append(os.path.join(fruit_dir, filename))                    labels.append(label)    X = []    y = np.array(labels)    for path in image_paths:        image = cv2.imread(path)        if image is None:            print(f&quot;警告：无法读取图像 &#123;path&#125;，请检查文件路径。&quot;)            continue        shape_features = extract_shape_features(image)        texture_features = extract_texture_features(image)        features = np.hstack((shape_features, texture_features))        X.append(features)    return np.array(X), y# 使用 JPEGImages 目录进行数据准备base_dir = &#x27;JPEGImages&#x27;X, y = prepare_data(base_dir)# 归一化特征scaler = StandardScaler()X = scaler.fit_transform(X)\n\n\n\n3 模型训练模型训练大致分以下几步：\n\n数据划分：将数据划分为80%训练集和20%测试集，以确保模型在未知数据上的泛化能力。\n\n模型创建和训练：创建逻辑回归模型，并使用训练集进行训练。逻辑回归是一种常用的分类算法，\n适用于多分类任务。\n\n模型预测：使用训练好的模型对测试集进行预测，得到预测标签。\n\n准确率计算：计算预测标签与真实标签之间的准确率，评估模型性能。\n\n\n\n\n\n\n\n\n\n\n\n（经检验运行后发现准确率不是非常理想，我猜测既因数据集较少、泛化能力不够，也因这类方法在分类水果上有一定的局限性，是特征提取方法存在的局限）\n\n点击这里查看上述步骤的代码\n1234567891011121314# 划分训练集和测试集X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)# 创建逻辑回归模型并训练model = LogisticRegression(max_iter=1000)model.fit(X_train, y_train)# 模型预测y_pred = model.predict(X_test)# 计算准确率accuracy = accuracy_score(y_test, y_pred)#print(f&quot;模型准确率: &#123;accuracy:.2f&#125;&quot;)\n\n\n\n4 单个图像预测最后我们可以利用之前训练好的模型进行图片预测,可以将其封装成一个函数，函数实现步骤如下：\n\n读取图像：使用 cv2.imread 读取待测试的图像。\n特征提取：提取图像的形状特征和纹理特征。\n合并特征：将形状特征和纹理特征合并为一个特征向量，并重塑为 (1, -1) 形状。\n特征缩放：使用预先训练好的 scaler 对特征进行缩放处理。\n模型预测：使用训练好的模型对缩放后的特征进行预测。\n\n\n点击这里查看图片预测函数\n12345678910111213# 单个图像分类示例def predict_image(image_path):    image = cv2.imread(image_path)    if image is None:        print(f&quot;无法读取图像 &#123;image_path&#125;，请检查路径。&quot;)        return None    shape_features = extract_shape_features(image)    texture_features = extract_texture_features(image)    features = np.hstack((shape_features, texture_features)).reshape(1, -1)    features = scaler.transform(features)    prediction = model.predict(features)    return prediction[0]\n\n\n\n最后将要测试的图片的路径修改入代码之中，运行之后即可看到预测的结果，结果如下\n\n5 完结撒花\n","slug":"水果分类识别","date":"2024-09-06T13:41:30.558Z","categories_index":"机器学习","tags_index":"逻辑回归,水果分类,计算机视觉","author_index":"神秘奇男子"},{"id":"dc76bdb116b22b7d8e614c5e499a6c3f","title":"Haar 特征分类器实现人脸识别","content":"基于OpenCV 的 Haar 特征分类器实现人脸检测与显示在计算机视觉领域，人脸检测是非常基础而且常用的技术，最近刚好在学计算机视觉的相关知识，学到人脸识别时，感到比较有趣\n于是简单写一下我的实现过程。[](￣▽￣)*\n本文将展示如何使用 OpenCV 和 Python 来实现简单的人脸检测，并使用 Matplotlib 对结果进行可视化。\n1. 环境配置首先，我们需要确保已安装必要的库：\n1pip install opencv-python matplotlib\n\n2. 代码实现代码分为几个关键部分：图像的读取与处理、人脸检测、绘制矩形框以及结果显示。\n2.1. 导入所需的库我们首先导入 OpenCV 和 Matplotlib，用于图像处理和结果显示。\n12import cv2import matplotlib.pyplot as plt\n\n2.2. 定义显示图像的函数为了更好地展示图像，我定义了一个 show_img 函数，将 BGR 格式的图像转换为 RGB 格式，并用 Matplotlib 显示出来。\n123456def show_img(img, title, pos):    img_RGB = img[:, :, ::-1]  # BGR 转 RGB    plt.subplot(2, 2, pos)    plt.title(title)    plt.imshow(img_RGB)    plt.xticks([])  # 隐藏 x 轴刻度\n\n2.3. 绘制人脸矩形框的函数plot_rectangle 函数用于在人脸检测结果中绘制矩形框：\n1234def plot_rectangle(img, faces):    for (x, y, w, h) in faces:        cv2.rectangle(img, (x, y), (x + w, y + h), (0, 255, 255), 2)  # 绘制黄色矩形框    return img\n\n2.4. 主程序主程序中，我们加载图像、转换为灰度图，并使用 OpenCV 的 Haar 特征分类器进行人脸检测。最后，绘制检测到的人脸并显示图像。\n123456789101112def main():    image = cv2.imread(&quot;../resources/tg009.jpg&quot;)  # 读取图像    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)  # 转为灰度图    face_cascade = cv2.CascadeClassifier(&quot;haarcascade_frontalface_alt.xml&quot;)  # 加载分类器    faces = face_cascade.detectMultiScale(gray)  # 人脸检测    face_alt2 = plot_rectangle(image.copy(), faces)  # 绘制矩形框    plt.figure(figsize=(10, 10))    plt.suptitle(&quot;Face Detection&quot;, fontsize=14, fontweight=&quot;bold&quot;)    show_img(face_alt2, &quot;face_alt2&quot;, 1)    plt.show()\n\n\n\n\n\n\n\n\n\n\n\n\nWARNING\n上面代码值得注意的是,haarcascade_frontalface_alt2.xml分类器我是从opencv源码里面复制的，  还有其他几种分类器可以用:\n\n\n代码的运行效果如图所示：检测到的人脸区域被黄色矩形框标出，结果被显示在 Matplotlib 窗口中。\n\n3. 运行结果分析可以看到，最后效果并不是那么好，因为这个算法是比较老的了，现在利用深度学习的算法能做到非常精准，因此本方法了解一下就行。\n4. 结论本篇文章展示了如何使用 Python 和 OpenCV 实现人脸检测，以及如何利用 Matplotlib 对结果进行可视化。在实际项目中，人脸检测可以被应用于多种场景，如监控系统、智能门禁和人脸识别考勤等。\n","slug":"基于OpenCV 的 Haar 特征分类器实现人脸检测与显示","date":"2024-08-24T06:37:38.807Z","categories_index":"计算机视觉","tags_index":"OpenCV,人脸识别","author_index":"神秘奇男子"},{"id":"3ceded50fe0dd372bcf8c1a5f8350431","title":"Welcome to AUG's Blog","content":"\nHello,你们好！（づ￣3￣）づ╭❤️～欢迎来到我的博客我会不定期持续更新文章,欢迎大家批评指正","slug":"hello-world","date":"2024-08-21T13:16:45.064Z","categories_index":"","tags_index":"博客简介","author_index":"神秘奇男子"}]