[{"id":"a1a68e61fba08a00939dcebf3ef65f10","title":"水果分类识别优化","content":"任务二：水果分类识别优化txt首先回顾一下之前的大体实现思路：先前整体思路流程\n特征提取：从图像中提取两类特征（边界特征和纹理特征），用于描述水果的形状和表面纹理。\n\n数据处理：读取数据目录中的图像，提取特征并准备数据集。\n\n模型训练：使用提取的特征数据训练一个逻辑回归模型，并保存为一个模型文件以待调用。\n\n单个图像预测：使用训练好的模型对单个图像进行预测，并输出预测结果。\n\n\n1.优化角度一：增加一个对比度特征向量的提取\n随机在图像内取两个点作大小随机的矩阵，计算两矩阵的均值，若第一个矩阵的均值大就记为1，否则记为0.\n这样取n次构成一个n维的特征向量，生成对比度特征向量。\n此后提取其他图像的这样的对比度的特征向量，用和之前相同的取矩阵的位置方法。\n\n为了确保提取特征的一致性，我们需要在 第一次随机取矩阵 时记录下所选的矩阵位置和大小，之后无论是训练其他样本还是对新图像进行预测，都使用相同的矩阵位置和大小。这样能保证特征提取方式在整个数据集和测试阶段都是一致的。\n\n点击这里查看对比度特征向量提取代码\n123456789101112131415161718192021222324252627282930313233343536# 对比度特征提取函数（记录并使用相同的矩阵位置）def extract_contrast_features(image, n=10, positions=None, is_training=True):    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)    h, w = gray.shape    contrast_features = []    global matrix_positions    if is_training and positions is None:        matrix_positions = []  # 初始化矩阵位置    for i in range(n):        if is_training and positions is None:  # 训练时，生成矩阵并保存位置            x1, y1 = random.randint(0, w - 1), random.randint(0, h - 1)            x2, y2 = random.randint(0, w - 1), random.randint(0, h - 1)            size = random.randint(1, min(w, h) // 5)  # 矩阵大小            size1, size2 = size, size            matrix_positions.append(((x1, y1, size1), (x2, y2, size2)))  # 保存位置信息        elif positions and i &lt; len(positions):  # 确保矩阵位置足够，避免超出范围            ((x1, y1, size1), (x2, y2, size2)) = positions[i]        else:            raise IndexError(f&quot;矩阵位置不足，尝试访问第 &#123;i&#125; 个矩阵位置&quot;)        # 确保矩阵大小在图像边界内        size1 = min(size1, w - x1, h - y1)        size2 = min(size2, w - x2, h - y2)        roi1 = gray[y1:y1 + size1, x1:x1 + size1]        roi2 = gray[y2:y2 + size2, x2:x2 + size2]        mean1 = np.mean(roi1) if roi1.size &gt; 0 else 0        mean2 = np.mean(roi2) if roi2.size &gt; 0 else 0        contrast_features.append(1 if mean1 &gt; mean2 else 0)    return np.array(contrast_features)\n\n\n\n2.优化角度二：使用 CNN 替代逻辑回归模型在之前的实现中，使用了逻辑回归模型来处理从图像中提取的边界特征、纹理特征和对比度特征。这种方法在特定任务上可以取得一定的效果，但当数据规模增加或特征变得更加复杂时，逻辑回归的表达能力有限。\n为了更好地处理图像分类任务，我们可以采用卷积神经网络（CNN），它能更高效地提取图像中的空间特征，并在分类任务中通常能表现出优异的效果。\n2.1.为什么选择 CNN？\n局部感受野：卷积神经网络通过卷积操作可以捕捉图像中的局部特征，如边缘、纹理等，而这些特征对图像分类非常重要。\n参数共享：卷积核参数共享，减少了模型的参数量，相对于全连接层来说更高效。\n空间不变性：卷积操作可以在图像不同位置捕捉到类似的模式，有助于处理不同位置的图像特征。\n\n2.2.CNN 模型设计为了保持对比度、边界和纹理特征的使用，同时引入 CNN 模型，我们可以将提取的特征输入到 CNN 中，通过卷积层和池化层进一步提取高层次的特征，并通过全连接层输出最终的分类结果。\n2.3.CNN 模型结构\n卷积层（Conv Layer）\n使用多层卷积操作提取图像的局部特征。每一层卷积层提取的特征会随着层数的增加逐渐从低级特征（如边缘）变为高级特征（如复杂的形状）。\n\n\n池化层（Pooling Layer）\n池化层用于减少特征图的大小，同时保持重要的特征，通常使用最大池化（MaxPooling）。\n\n\n全连接层（Fully Connected Layer）\n将卷积和池化操作后的特征展平，并通过全连接层进行分类。\n\n\n\n2.4.模型实现在模型实现中，首先需要对数据进行预处理，将提取的特征转换为适合 CNN 的输入格式。接着，我们通过卷积层和池化层对图像进行处理，最后通过全连接层输出分类结果。\n\n以下是 CNN 模型的结构和训练流程的实现：\n12345678910111213141516171819202122232425262728# CNN 模型定义class CNNModel(nn.Module):    def __init__(self, input_size):        super(CNNModel, self).__init__()                # 定义卷积层        self.conv1 = nn.Conv2d(1, 32, kernel_size=3, stride=1, padding=1)        self.conv2 = nn.Conv2d(32, 64, kernel_size=3, stride=1, padding=1)                # 定义全连接层        self.fc1 = nn.Linear(64 * 7 * 7, 128)        self.fc2 = nn.Linear(128, 3)  # 对应3个类别                # 定义池化层        self.pool = nn.MaxPool2d(2, 2)    def forward(self, x):        # 卷积层 + 激活函数 + 池化        x = self.pool(torch.relu(self.conv1(x)))        x = self.pool(torch.relu(self.conv2(x)))                # 展平层        x = x.view(-1, 64 * 7 * 7)                # 全连接层        x = torch.relu(self.fc1(x))        x = self.fc2(x)        return x\n\n\n\n2.5.数据处理为了适应 CNN 的输入要求，我们需要将提取的特征调整为二维形式，并且添加一个通道维度。\n\n数据的预处理如下所示：\n12345678910# 调整数据为 2D 图像形式 (batch_size, channels, height, width)X_train = X_train.reshape(-1, 1, 28, 28)X_test = X_test.reshape(-1, 1, 28, 28)# 转换为 PyTorch 数据集train_dataset = FruitDataset(X_train, y_train)test_dataset = FruitDataset(X_test, y_test)train_loader = DataLoader(train_dataset, batch_size=32, shuffle=True)test_loader = DataLoader(test_dataset, batch_size=32, shuffle=False)\n\n\n\n2.6.模型训练接下来，我们定义了模型的训练过程，包括损失函数和优化器的选择，使用交叉熵损失和 Adam 优化器：\n\n模型训练代码\n1234567891011121314151617181920212223242526# 创建 CNN 模型input_size = 28 * 28  # 输入图像大小 28x28model = CNNModel(input_size)# 使用交叉熵损失criterion = nn.CrossEntropyLoss()# 使用 Adam 优化器optimizer = optim.Adam(model.parameters(), lr=0.001)# 训练模型n_epochs = 10for epoch in range(n_epochs):    model.train()    running_loss = 0.0    for inputs, labels in train_loader:        optimizer.zero_grad()        outputs = model(inputs)        loss = criterion(outputs, labels)        loss.backward()        optimizer.step()        running_loss += loss.item()    print(f&quot;Epoch &#123;epoch + 1&#125;/&#123;n_epochs&#125;, Loss: &#123;running_loss / len(train_loader)&#125;&quot;)# 保存模型torch.save(model.state_dict(), &#x27;cnn_model.pth&#x27;)\n\n\n\n2.7.模型评估训练完成后，我们在测试集上对模型进行评估，通过计算准确率、精度、召回率等指标来衡量模型的性能：\n\n模型评估代码\n1234567891011121314151617181920212223# 评估模型model.eval()y_true = []y_pred = []with torch.no_grad():    for inputs, labels in test_loader:        outputs = model(inputs)        _, predicted = torch.max(outputs, 1)        y_true.extend(labels.numpy())        y_pred.extend(predicted.numpy())# 计算准确率、精度、召回率accuracy = accuracy_score(y_true, y_pred)precision = precision_score(y_true, y_pred, average=&#x27;weighted&#x27;)recall = recall_score(y_true, y_pred, average=&#x27;weighted&#x27;)print(f&quot;准确率: &#123;accuracy:.2f&#125;&quot;)print(f&quot;精度: &#123;precision:.2f&#125;&quot;)print(f&quot;召回率: &#123;recall:.2f&#125;&quot;)# 输出完整的分类报告print(&quot;\\n分类报告：&quot;)print(classification_report(y_true, y_pred, target_names=[&#x27;苹果&#x27;, &#x27;香蕉&#x27;, &#x27;橙子&#x27;]))\n\n\n\n\n这一次的优化，使得水果分类识别模型的泛化能力、识别能力更强。通过结合对比度特征的提取和 CNN 模型，我们能够更好地捕捉图像的细节特征，提升分类的准确性。\n","slug":"水果分类优化","date":"2024-09-22T02:40:45.060Z","categories_index":"深度学习","tags_index":"CNN,水果分类,计算机视觉","author_index":"神秘奇男子"},{"id":"f50948573c1bc1468571d16f17cedea9","title":"MybatisPlus入门","content":"MybatisPlus入门[TOC]\n1. 简介​\t\n​\t大家在日常开发中应该能发现，单表的CRUD功能代码重复度很高，也没有什么难度。而这部分代码量往往比较大，开发起来比较费时。\n​\t\n​\t因此，目前企业中都会使用一些组件来简化或省略单表的CRUD开发工作。目前在国内使用较多的一个组件就是MybatisPlus.\n​\tMyBatis-Plus 是一个 MyBatis 的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。\n:::warning它的愿景是成为 MyBatis 最好的搭档，就像 魂斗罗 中的 1P、2P，基友搭配，效率翻倍。:::​\t\n\n2.快速入门比如我们要实现User表的CRUD，只需要下面几步：\n\n引入MybatisPlus依赖\n定义Mapper\n\n2.1引入依赖MybatisPlus提供了starter，实现了自动Mybatis以及MybatisPlus的自动装配功能，坐标如下：\n12345&lt;dependency&gt;    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;    &lt;version&gt;3.5.3.1&lt;/version&gt;&lt;/dependency&gt;\n\n由于这个starter包含对mybatis的自动装配，因此完全可以替换掉Mybatis的starter。\n2.2定义Mapper为了简化单表CRUD，MybatisPlus提供了一个基础的BaseMapper接口，其中已经实现了单表的CRUD：\n因此我们自定义的Mapper只要实现了这个BaseMapper，就无需自己实现单表CRUD了。\n2.3常见注解MybatisPlus如何知道我们要查询的是哪张表？表中有哪些字段呢？\nUserMapper在继承BaseMapper的时候指定了一个泛型：\n1public interface UserMapper extends BaseMapper&lt;User&gt;\n\n泛型中的User就是与数据库对应的PO.\nMybatisPlus就是根据PO实体的信息来推断出表的信息，从而生成SQL的。默认情况下：\n\nMybatisPlus会把PO实体的类名驼峰转下划线作为表名\nMybatisPlus会把PO实体的所有变量名驼峰转下划线作为表的字段名，并根据变量类型推断字段类型\nMybatisPlus会把名为id的字段作为主键\n\n但很多情况下，默认的实现与实际场景不符，因此MybatisPlus提供了一些注解便于我们声明表信息。\n2.3.1.@TableName说明：\n\n描述：表名注解，标识实体类对应的表\n使用位置：实体类\n\n示例：\n12345@TableName(&quot;user&quot;)public class User &#123;    private Long id;    private String name;&#125;\n\nTableName注解除了指定表名以外，还可以指定很多其它属性：\n\n\n\n属性\n类型\n必须指定\n默认值\n描述\n\n\n\nvalue\nString\n否\n“”\n表名\n\n\nschema\nString\n否\n“”\nschema\n\n\nkeepGlobalPrefix\nboolean\n否\nfalse\n是否保持使用全局的 tablePrefix 的值（当全局 tablePrefix 生效时）\n\n\nresultMap\nString\n否\n“”\nxml 中 resultMap 的 id（用于满足特定类型的实体类对象绑定）\n\n\nautoResultMap\nboolean\n否\nfalse\n是否自动构建 resultMap 并使用（如果设置 resultMap 则不会进行 resultMap 的自动构建与注入）\n\n\nexcludeProperty\nString[]\n否\n{}\n需要排除的属性名 @since 3.3.1\n\n\n2.3.2.@TableId说明：\n\n描述：主键注解，标识实体类中的主键字段\n使用位置：实体类的主键字段\n\n示例：\n123456@TableName(&quot;user&quot;)public class User &#123;    @TableId    private Long id;    private String name;&#125;\n\nTableId注解支持两个属性：\n\n\n\n属性\n类型\n必须指定\n默认值\n描述\n\n\n\nvalue\nString\n否\n“”\n表名\n\n\ntype\nEnum\n否\nIdType.NONE\n指定主键类型\n\n\nIdType支持的类型有：\n\n\n\n值\n描述\n\n\n\nAUTO\n数据库 ID 自增\n\n\nNONE\n无状态，该类型为未设置主键类型（注解里等于跟随全局，全局里约等于 INPUT）\n\n\nINPUT\ninsert 前自行 set 主键值\n\n\nASSIGN_ID\n分配 ID(主键类型为 Number(Long 和 Integer)或 String)(since 3.3.0),使用接口IdentifierGenerator的方法nextId(默认实现类为DefaultIdentifierGenerator雪花算法)\n\n\nASSIGN_UUID\n分配 UUID,主键类型为 String(since 3.3.0),使用接口IdentifierGenerator的方法nextUUID(默认 default 方法)\n\n\nID_WORKER\n分布式全局唯一 ID 长整型类型(please use ASSIGN_ID)\n\n\nUUID\n32 位 UUID 字符串(please use ASSIGN_UUID)\n\n\nID_WORKER_STR\n分布式全局唯一 ID 字符串类型(please use ASSIGN_ID)\n\n\n这里比较常见的有三种：\n\nAUTO：利用数据库的id自增长\nINPUT：手动生成id\nASSIGN_ID：雪花算法生成Long类型的全局唯一id，这是默认的ID策略\n\n2.3.3.@TableField说明：\n\n\n\n\n\n\n\n\n\n描述：普通字段注解\n示例：\n1234567891011@TableName(&quot;user&quot;)public class User &#123;    @TableId    private Long id;    private String name;    private Integer age;    @TableField(&quot;isMarried&quot;)    private Boolean isMarried;    @TableField(&quot;concat&quot;)    private String concat;&#125;\n\n一般情况下我们并不需要给字段添加@TableField注解，一些特殊情况除外：\n\n成员变量名与数据库字段名不一致\n成员变量是以isXXX命名，按照JavaBean的规范，MybatisPlus识别字段时会把is去除，这就导致与数据库不符。\n成员变量名与数据库一致，但是与数据库的关键字冲突。使用@TableField注解给字段名添加转义字符：&#96;&#96;&#96;&#96;\n\n支持的其它属性如下：\n\n\n\n属性\n类型\n必填\n默认值\n描述\n\n\n\nvalue\nString\n否\n“”\n数据库字段名\n\n\nexist\nboolean\n否\ntrue\n是否为数据库表字段\n\n\ncondition\nString\n否\n“”\n字段 where 实体查询比较条件，有值设置则按设置的值为准，没有则为默认全局的 ，参考(opens new window)\n\n\nupdate\nString\n否\n“”\n字段 update set 部分注入，例如：当在version字段上注解update&#x3D;”%s+1” 表示更新时会 set version&#x3D;version+1 （该属性优先级高于 el 属性）\n\n\ninsertStrategy\nEnum\n否\nFieldStrategy.DEFAULT\n举例：NOT_NULL insert into table_a(column) values (#{columnProperty})\n\n\nupdateStrategy\nEnum\n否\nFieldStrategy.DEFAULT\n举例：IGNORED update table_a set column&#x3D;#{columnProperty}\n\n\nwhereStrategy\nEnum\n否\nFieldStrategy.DEFAULT\n举例：NOT_EMPTY where column&#x3D;#{columnProperty}\n\n\nfill\nEnum\n否\nFieldFill.DEFAULT\n字段自动填充策略\n\n\nselect\nboolean\n否\ntrue\n是否进行 select 查询\n\n\nkeepGlobalFormat\nboolean\n否\nfalse\n是否保持使用全局的 format 进行处理\n\n\njdbcType\nJdbcType\n否\nJdbcType.UNDEFINED\nJDBC 类型 (该默认值不代表会按照该值生效)\n\n\ntypeHandler\nTypeHander\n否\n\n类型处理器 (该默认值不代表会按照该值生效)\n\n\nnumericScale\nString\n否\n“”\n指定小数点后保留的位数\n\n\n2.4常见配置MybatisPlus也支持基于yaml文件的自定义配置。\n大多数的配置都有默认值，因此我们都无需配置。但还有一些是没有默认值的，例如:\n\n实体类的别名扫描包\n全局id类型\n\n12345mybatis-plus:  type-aliases-package: com.itheima.mp.domain.po  global-config:    db-config:      id-type: auto # 全局id类型为自增长\n\n需要注意的是，MyBatisPlus也支持手写SQL的，而mapper文件的读取地址可以自己配置：\n12mybatis-plus:  mapper-locations: &quot;classpath*:/mapper/**/*.xml&quot; # Mapper.xml文件地址，当前这个是默认值。\n\n可以看到默认值是classpath*:/mapper/**/*.xml，也就是说我们只要把mapper.xml文件放置这个目录下就一定会被加载。\n3.核心功能刚才的案例中都是以id为条件的简单CRUD，一些复杂条件的SQL语句就要用到一些更高级的功能了。\n3.1.条件构造器除了新增以外，修改、删除、查询的SQL语句都需要指定where条件。因此BaseMapper中提供的相关方法除了以id作为where条件以外，还支持更加复杂的where条件。\n3.1.1.QueryWrapper无论是修改、删除、查询，都可以使用QueryWrapper来构建查询条件。接下来看一些例子： 查询：查询出名字中带o的，存款大于等于1000元的人。代码如下：\n1234567891011@Testvoid testQueryWrapper() &#123;    // 1.构建查询条件 where name like &quot;%o%&quot; AND balance &gt;= 1000    QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;User&gt;()            .select(&quot;id&quot;, &quot;username&quot;, &quot;info&quot;, &quot;balance&quot;)            .like(&quot;username&quot;, &quot;o&quot;)            .ge(&quot;balance&quot;, 1000);    // 2.查询数据    List&lt;User&gt; users = userMapper.selectList(wrapper);    users.forEach(System.out::println);&#125;\n\n更新：更新用户名为jack的用户的余额为2000，代码如下：\n123456789@Testvoid testUpdateByQueryWrapper() &#123;    // 1.构建查询条件 where name = &quot;Jack&quot;    QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;User&gt;().eq(&quot;username&quot;, &quot;Jack&quot;);    // 2.更新数据，user中非null字段都会作为set语句    User user = new User();    user.setBalance(2000);    userMapper.update(user, wrapper);&#125;\n\n\n\n3.1.2.UpdateWrapper基于BaseMapper中的update方法更新时只能直接赋值，对于一些复杂的需求就难以实现。 例如：更新id为1,2,4的用户的余额，扣200，对应的SQL应该是：\n1UPDATE user SET balance = balance - 200 WHERE id in (1, 2, 4)\n\nSET的赋值结果是基于字段现有值的，这个时候就要利用UpdateWrapper中的setSql功能了：\n1234567891011@Testvoid testUpdateWrapper() &#123;    List&lt;Long&gt; ids = List.of(1L, 2L, 4L);    // 1.生成SQL    UpdateWrapper&lt;User&gt; wrapper = new UpdateWrapper&lt;User&gt;()            .setSql(&quot;balance = balance - 200&quot;) // SET balance = balance - 200            .in(&quot;id&quot;, ids); // WHERE id in (1, 2, 4)        // 2.更新，注意第一个参数可以给null，也就是不填更新字段和数据，    // 而是基于UpdateWrapper中的setSQL来更新    userMapper.update(null, wrapper);&#125;\n\n3.1.3.LambdaQueryWrapper无论是QueryWrapper还是UpdateWrapper在构造条件的时候都需要写死字段名称，会出现字符串魔法值。这在编程规范中显然是不推荐的。 那怎么样才能不写字段名，又能知道字段名呢？\n其中一种办法是基于变量的gettter方法结合反射技术。因此我们只要将条件对应的字段的getter方法传递给MybatisPlus，它就能计算出对应的变量名了。而传递方法可以使用JDK8中的方法引用和Lambda表达式。 因此MybatisPlus又提供了一套基于Lambda的Wrapper，包含两个：\n\nLambdaQueryWrapper\nLambdaUpdateWrapper\n\n分别对应QueryWrapper和UpdateWrapper\n其使用方式如下：\n123456789101112@Testvoid testLambdaQueryWrapper() &#123;    // 1.构建条件 WHERE username LIKE &quot;%o%&quot; AND balance &gt;= 1000    QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;();    wrapper.lambda()            .select(User::getId, User::getUsername, User::getInfo, User::getBalance)            .like(User::getUsername, &quot;o&quot;)            .ge(User::getBalance, 1000);    // 2.查询    List&lt;User&gt; users = userMapper.selectList(wrapper);    users.forEach(System.out::println);&#125;\n\n\n\n\n\n\n\n3.2.自定义SQL在演示UpdateWrapper的案例中，我们在代码中编写了更新的SQL语句：\n这种写法在某些企业也是不允许的，因为SQL语句最好都维护在持久层，而不是业务层。就当前案例来说，由于条件是in语句，只能将SQL写在Mapper.xml文件，利用foreach来生成动态SQL。 这实在是太麻烦了。假如查询条件更复杂，动态SQL的编写也会更加复杂。\n所以，MybatisPlus提供了自定义SQL功能，可以让我们利用Wrapper生成查询条件，再结合Mapper.xml编写SQL\n3.2.1.基本用法以当前案例来说，我们可以这样写：\n123456789@Testvoid testCustomWrapper() &#123;    // 1.准备自定义查询条件    List&lt;Long&gt; ids = List.of(1L, 2L, 4L);    QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;User&gt;().in(&quot;id&quot;, ids);    // 2.调用mapper的自定义方法，直接传递Wrapper    userMapper.deductBalanceByIds(200, wrapper);&#125;\n\n然后在UserMapper中自定义SQL：\n123456789101112package com.itheima.mp.mapper;import com.baomidou.mybatisplus.core.mapper.BaseMapper;import com.itheima.mp.domain.po.User;import org.apache.ibatis.annotations.Param;import org.apache.ibatis.annotations.Update;import org.apache.ibatis.annotations.Param;public interface UserMapper extends BaseMapper&lt;User&gt; &#123;    @Select(&quot;UPDATE user SET balance = balance - #&#123;money&#125; $&#123;ew.customSqlSegment&#125;&quot;)    void deductBalanceByIds(@Param(&quot;money&quot;) int money, @Param(&quot;ew&quot;) QueryWrapper&lt;User&gt; wrapper);&#125;\n\n这样就省去了编写复杂查询条件的烦恼了。\n3.2.2.多表关联理论上来讲MyBatisPlus是不支持多表查询的，不过我们可以利用Wrapper中自定义条件结合自定义SQL来实现多表查询的效果。 例如，我们要查询出所有收货地址在北京的并且用户id在1、2、4之中的用户 要是自己基于mybatis实现SQL，大概是这样的：\n12345678910&lt;select id=&quot;queryUserByIdAndAddr&quot; resultType=&quot;com.itheima.mp.domain.po.User&quot;&gt;      SELECT *      FROM user u      INNER JOIN address a ON u.id = a.user_id      WHERE u.id      &lt;foreach collection=&quot;ids&quot; separator=&quot;,&quot; item=&quot;id&quot; open=&quot;IN (&quot; close=&quot;)&quot;&gt;          #&#123;id&#125;      &lt;/foreach&gt;      AND a.city = #&#123;city&#125;  &lt;/select&gt;\n\n可以看出其中最复杂的就是WHERE条件的编写，如果业务复杂一些，这里的SQL会更变态。\n但是基于自定义SQL结合Wrapper的玩法，我们就可以利用Wrapper来构建查询条件，然后手写SELECT及FROM部分，实现多表查询。\n查询条件这样来构建：\n123456789101112@Testvoid testCustomJoinWrapper() &#123;    // 1.准备自定义查询条件    QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;User&gt;()            .in(&quot;u.id&quot;, List.of(1L, 2L, 4L))            .eq(&quot;a.city&quot;, &quot;北京&quot;);    // 2.调用mapper的自定义方法    List&lt;User&gt; users = userMapper.queryUserByWrapper(wrapper);    users.forEach(System.out::println);&#125;\n\n然后在UserMapper中自定义方法：\n12@Select(&quot;SELECT u.* FROM user u INNER JOIN address a ON u.id = a.user_id $&#123;ew.customSqlSegment&#125;&quot;)List&lt;User&gt; queryUserByWrapper(@Param(&quot;ew&quot;)QueryWrapper&lt;User&gt; wrapper);\n\n当然，也可以在UserMapper.xml中写SQL：\n123&lt;select id=&quot;queryUserByIdAndAddr&quot; resultType=&quot;com.itheima.mp.domain.po.User&quot;&gt;    SELECT * FROM user u INNER JOIN address a ON u.id = a.user_id $&#123;ew.customSqlSegment&#125;&lt;/select&gt;\n\n\n\n\n\n\n\n3.3.Service接口MybatisPlus不仅提供了BaseMapper，还提供了通用的Service接口及默认实现，封装了一些常用的service模板方法。 通用接口为IService，默认实现为ServiceImpl，其中封装的方法可以分为以下几类：\n\nsave：新增\nremove：删除\nupdate：更新\nget：查询单个结果\nlist：查询集合结果\ncount：计数\npage：分页查询\n\n3.3.1.CRUD我们先俩看下基本的CRUD接口。 \n新增：\n\nsave是新增单个元素\nsaveBatch是批量新增\nsaveOrUpdate是根据id判断，如果数据存在就更新，不存在则新增\nsaveOrUpdateBatch是批量的新增或修改\n\n删除：\n\nremoveById：根据id删除\nremoveByIds：根据id批量删除\nremoveByMap：根据Map中的键值对为条件删除\nremove(Wrapper&lt;T&gt;)：根据Wrapper条件删除\n~~removeBatchByIds~~：暂不支持\n\n修改：\n\nupdateById：根据id修改\nupdate(Wrapper&lt;T&gt;)：根据UpdateWrapper修改，Wrapper中包含set和where部分\nupdate(T，Wrapper&lt;T&gt;)：按照T内的数据修改与Wrapper匹配到的数据\nupdateBatchById：根据id批量修改\n\nGet：\n\ngetById：根据id查询1条数据\ngetOne(Wrapper&lt;T&gt;)：根据Wrapper查询1条数据\ngetBaseMapper：获取Service内的BaseMapper实现，某些时候需要直接调用Mapper内的自定义SQL时可以用这个方法获取到Mapper\n\nList：\n\nlistByIds：根据id批量查询\nlist(Wrapper&lt;T&gt;)：根据Wrapper条件查询多条数据\nlist()：查询所有\n\nCount：\n\ncount()：统计所有数量\ncount(Wrapper&lt;T&gt;)：统计符合Wrapper条件的数据数量\n\ngetBaseMapper： 当我们在service中要调用Mapper中自定义SQL时，就必须获取service对应的Mapper，就可以通过这个方法：\n3.3.2.基本用法由于Service中经常需要定义与业务有关的自定义方法，因此我们不能直接使用IService，而是自定义Service接口，然后继承IService以拓展方法。同时，让自定义的Service实现类继承ServiceImpl，这样就不用自己实现IService中的接口了。\n首先，定义IUserService，继承IService：\n12345678package com.itheima.mp.service;import com.baomidou.mybatisplus.extension.service.IService;import com.itheima.mp.domain.po.User;public interface IUserService extends IService&lt;User&gt; &#123;    // 拓展自定义方法&#125;\n\n然后，编写UserServiceImpl类，继承ServiceImpl，实现UserService：\n123456789101112package com.itheima.mp.service.impl;import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;import com.itheima.mp.domain.po.User;import com.itheima.mp.domain.po.service.IUserService;import com.itheima.mp.mapper.UserMapper;import org.springframework.stereotype.Service;@Servicepublic class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt;                                                                                                        implements IUserService &#123;&#125;\n\n项目结构如下：\n接下来，我们快速实现下面4个接口：\n\n\n\n编号\n接口\n请求方式\n请求路径\n请求参数\n返回值\n\n\n\n1\n新增用户\nPOST\n&#x2F;users\n用户表单实体\n无\n\n\n2\n删除用户\nDELETE\n&#x2F;users&#x2F;{id}\n用户id\n无\n\n\n3\n根据id查询用户\nGET\n&#x2F;users&#x2F;{id}\n用户id\n用户VO\n\n\n4\n根据id批量查询\nGET\n&#x2F;users\n用户id集合\n用户VO集合\n\n\n首先，我们在项目中引入几个依赖：\n1234567891011&lt;!--swagger--&gt;&lt;dependency&gt;    &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt;    &lt;artifactId&gt;knife4j-openapi2-spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;4.1.0&lt;/version&gt;&lt;/dependency&gt;&lt;!--web--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;\n\n然后需要配置swagger信息：\n123456789101112131415knife4j:  enable: true  openapi:    title: 用户管理接口文档    description: &quot;用户管理接口文档&quot;    email: zhanghuyi@itcast.cn    concat: 虎哥    url: https://www.itcast.cn    version: v1.0.0    group:      default:        group-name: default        api-rule: package        api-rule-resources:          - com.itheima.mp.controller\n\n然后，接口需要两个实体：\n\nUserFormDTO：代表新增时的用户表单\nUserVO：代表查询的返回结果\n\n首先是UserFormDTO：\n123456789101112131415161718192021222324252627282930package com.itheima.mp.domain.dto;import com.baomidou.mybatisplus.annotation.TableField;import com.baomidou.mybatisplus.extension.handlers.JacksonTypeHandler;import io.swagger.annotations.ApiModel;import io.swagger.annotations.ApiModelProperty;import lombok.Data;@Data@ApiModel(description = &quot;用户表单实体&quot;)public class UserFormDTO &#123;    @ApiModelProperty(&quot;id&quot;)    private Long id;    @ApiModelProperty(&quot;用户名&quot;)    private String username;    @ApiModelProperty(&quot;密码&quot;)    private String password;    @ApiModelProperty(&quot;注册手机号&quot;)    private String phone;    @ApiModelProperty(&quot;详细信息，JSON风格&quot;)    private String info;    @ApiModelProperty(&quot;账户余额&quot;)    private Integer balance;&#125;\n\n然后是UserVO：\n12345678910111213141516171819202122232425package com.itheima.mp.domain.vo;import io.swagger.annotations.ApiModel;import io.swagger.annotations.ApiModelProperty;import lombok.Data;@Data@ApiModel(description = &quot;用户VO实体&quot;)public class UserVO &#123;        @ApiModelProperty(&quot;用户id&quot;)    private Long id;        @ApiModelProperty(&quot;用户名&quot;)    private String username;        @ApiModelProperty(&quot;详细信息&quot;)    private String info;    @ApiModelProperty(&quot;使用状态（1正常 2冻结）&quot;)    private Integer status;        @ApiModelProperty(&quot;账户余额&quot;)    private Integer balance;&#125;\n\n最后，按照Restful风格编写Controller接口方法：\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.itheima.mp.controller;import cn.hutool.core.bean.BeanUtil;import com.itheima.mp.domain.dto.UserFormDTO;import com.itheima.mp.domain.po.User;import com.itheima.mp.domain.vo.UserVO;import com.itheima.mp.service.IUserService;import io.swagger.annotations.Api;import io.swagger.annotations.ApiOperation;import lombok.RequiredArgsConstructor;import org.springframework.web.bind.annotation.*;import java.util.List;@Api(tags = &quot;用户管理接口&quot;)@RequiredArgsConstructor@RestController@RequestMapping(&quot;users&quot;)public class UserController &#123;    private final IUserService userService;    @PostMapping    @ApiOperation(&quot;新增用户&quot;)    public void saveUser(@RequestBody UserFormDTO userFormDTO)&#123;        // 1.转换DTO为PO        User user = BeanUtil.copyProperties(userFormDTO, User.class);        // 2.新增        userService.save(user);    &#125;    @DeleteMapping(&quot;/&#123;id&#125;&quot;)    @ApiOperation(&quot;删除用户&quot;)    public void removeUserById(@PathVariable(&quot;id&quot;) Long userId)&#123;        userService.removeById(userId);    &#125;    @GetMapping(&quot;/&#123;id&#125;&quot;)    @ApiOperation(&quot;根据id查询用户&quot;)    public UserVO queryUserById(@PathVariable(&quot;id&quot;) Long userId)&#123;        // 1.查询用户        User user = userService.getById(userId);        // 2.处理vo        return BeanUtil.copyProperties(user, UserVO.class);    &#125;    @GetMapping    @ApiOperation(&quot;根据id集合查询用户&quot;)    public List&lt;UserVO&gt; queryUserByIds(@RequestParam(&quot;ids&quot;) List&lt;Long&gt; ids)&#123;        // 1.查询用户        List&lt;User&gt; users = userService.listByIds(ids);        // 2.处理vo        return BeanUtil.copyToList(users, UserVO.class);    &#125;&#125;\n\n可以看到上述接口都直接在controller即可实现，无需编写任何service代码，非常方便。\n不过，一些带有业务逻辑的接口则需要在service中自定义实现了。例如下面的需求：\n\n根据id扣减用户余额\n\n这看起来是个简单修改功能，只要修改用户余额即可。但这个业务包含一些业务逻辑处理：\n\n判断用户状态是否正常\n判断用户余额是否充足\n\n这些业务逻辑都要在service层来做，另外更新余额需要自定义SQL，要在mapper中来实现。因此，我们除了要编写controller以外，具体的业务还要在service和mapper中编写。\n首先在UserController中定义一个方法：\n12345@PutMapping(&quot;&#123;id&#125;/deduction/&#123;money&#125;&quot;)@ApiOperation(&quot;扣减用户余额&quot;)public void deductBalance(@PathVariable(&quot;id&quot;) Long id, @PathVariable(&quot;money&quot;)Integer money)&#123;    userService.deductBalance(id, money);&#125;\n\n然后是UserService接口：\n12345678package com.itheima.mp.service;import com.baomidou.mybatisplus.extension.service.IService;import com.itheima.mp.domain.po.User;public interface IUserService extends IService&lt;User&gt; &#123;    void deductBalance(Long id, Integer money);&#125;\n\n最后是UserServiceImpl实现类：\n1234567891011121314151617181920212223242526package com.itheima.mp.service.impl;import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;import com.itheima.mp.domain.po.User;import com.itheima.mp.mapper.UserMapper;import com.itheima.mp.service.IUserService;import org.springframework.stereotype.Service;@Servicepublic class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt; implements IUserService &#123;    @Override    public void deductBalance(Long id, Integer money) &#123;        // 1.查询用户        User user = getById(id);        // 2.判断用户状态        if (user == null || user.getStatus() == 2) &#123;            throw new RuntimeException(&quot;用户状态异常&quot;);        &#125;        // 3.判断用户余额        if (user.getBalance() &lt; money) &#123;            throw new RuntimeException(&quot;用户余额不足&quot;);        &#125;        // 4.扣减余额        baseMapper.deductMoneyById(id, money);    &#125;&#125;\n\n最后是mapper：\n12@Update(&quot;UPDATE user SET balance = balance - #&#123;money&#125; WHERE id = #&#123;id&#125;&quot;)void deductMoneyById(@Param(&quot;id&quot;) Long id, @Param(&quot;money&quot;) Integer money);\n\n\n\n\n\n3.3.3.LambdaIService中还提供了Lambda功能来简化我们的复杂查询及更新功能。我们通过两个案例来学习一下。\n案例一：实现一个根据复杂条件查询用户的接口，查询条件如下：\n\nname：用户名关键字，可以为空\nstatus：用户状态，可以为空\nminBalance：最小余额，可以为空\nmaxBalance：最大余额，可以为空\n\n可以理解成一个用户的后台管理界面，管理员可以自己选择条件来筛选用户，因此上述条件不一定存在，需要做判断。\n我们首先需要定义一个查询条件实体，UserQuery实体：\n123456789101112131415161718package com.itheima.mp.domain.query;import io.swagger.annotations.ApiModel;import io.swagger.annotations.ApiModelProperty;import lombok.Data;@Data@ApiModel(description = &quot;用户查询条件实体&quot;)public class UserQuery &#123;    @ApiModelProperty(&quot;用户名关键字&quot;)    private String name;    @ApiModelProperty(&quot;用户状态：1-正常，2-冻结&quot;)    private Integer status;    @ApiModelProperty(&quot;余额最小值&quot;)    private Integer minBalance;    @ApiModelProperty(&quot;余额最大值&quot;)    private Integer maxBalance;&#125;\n\n接下来我们在UserController中定义一个controller方法：\n123456789101112131415161718@GetMapping(&quot;/list&quot;)@ApiOperation(&quot;根据id集合查询用户&quot;)public List&lt;UserVO&gt; queryUsers(UserQuery query)&#123;    // 1.组织条件    String username = query.getName();    Integer status = query.getStatus();    Integer minBalance = query.getMinBalance();    Integer maxBalance = query.getMaxBalance();    LambdaQueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;User&gt;().lambda()            .like(username != null, User::getUsername, username)            .eq(status != null, User::getStatus, status)            .ge(minBalance != null, User::getBalance, minBalance)            .le(maxBalance != null, User::getBalance, maxBalance);    // 2.查询用户    List&lt;User&gt; users = userService.list(wrapper);    // 3.处理vo    return BeanUtil.copyToList(users, UserVO.class);&#125;\n\n在组织查询条件的时候，我们加入了 username != null 这样的参数，意思就是当条件成立时才会添加这个查询条件，类似Mybatis的mapper.xml文件中的&lt;if&gt;标签。这样就实现了动态查询条件效果了。\n不过，上述条件构建的代码太麻烦了。 因此Service中对LambdaQueryWrapper和LambdaUpdateWrapper的用法进一步做了简化。我们无需自己通过new的方式来创建Wrapper，而是直接调用lambdaQuery和lambdaUpdate方法：\n基于Lambda查询：\n123456789101112131415161718@GetMapping(&quot;/list&quot;)@ApiOperation(&quot;根据id集合查询用户&quot;)public List&lt;UserVO&gt; queryUsers(UserQuery query)&#123;    // 1.组织条件    String username = query.getName();    Integer status = query.getStatus();    Integer minBalance = query.getMinBalance();    Integer maxBalance = query.getMaxBalance();    // 2.查询用户    List&lt;User&gt; users = userService.lambdaQuery()            .like(username != null, User::getUsername, username)            .eq(status != null, User::getStatus, status)            .ge(minBalance != null, User::getBalance, minBalance)            .le(maxBalance != null, User::getBalance, maxBalance)            .list();    // 3.处理vo    return BeanUtil.copyToList(users, UserVO.class);&#125;\n\n可以发现lambdaQuery方法中除了可以构建条件，还需要在链式编程的最后添加一个list()，这是在告诉MP我们的调用结果需要是一个list集合。这里不仅可以用list()，可选的方法有：\n\n.one()：最多1个结果\n.list()：返回集合结果\n.count()：返回计数结果\n\nMybatisPlus会根据链式编程的最后一个方法来判断最终的返回结果。\n与lambdaQuery方法类似，IService中的lambdaUpdate方法可以非常方便的实现复杂更新业务。\n例如下面的需求：\n\n\n\n\n\n\n\n\n\n需求：改造根据id修改用户余额的接口，要求如下\n\n如果扣减后余额为0，则将用户status修改为冻结状态（2）\n\n也就是说我们在扣减用户余额时，需要对用户剩余余额做出判断，如果发现剩余余额为0，则应该将status修改为2，这就是说update语句的set部分是动态的。\n实现如下：\n12345678910111213141516171819202122@Override@Transactionalpublic void deductBalance(Long id, Integer money) &#123;    // 1.查询用户    User user = getById(id);    // 2.校验用户状态    if (user == null || user.getStatus() == 2) &#123;        throw new RuntimeException(&quot;用户状态异常！&quot;);    &#125;    // 3.校验余额是否充足    if (user.getBalance() &lt; money) &#123;        throw new RuntimeException(&quot;用户余额不足！&quot;);    &#125;    // 4.扣减余额 update tb_user set balance = balance - ?    int remainBalance = user.getBalance() - money;    lambdaUpdate()            .set(User::getBalance, remainBalance) // 更新余额            .set(remainBalance == 0, User::getStatus, 2) // 动态判断，是否更新status            .eq(User::getId, id)            .eq(User::getBalance, user.getBalance()) // 乐观锁            .update();&#125;\n\n\n\n3.3.4.批量新增IService中的批量新增功能使用起来非常方便，但有一点注意事项，我们先来测试一下。 首先我们测试逐条插入数据：\n123456789101112131415161718192021@Testvoid testSaveOneByOne() &#123;    long b = System.currentTimeMillis();    for (int i = 1; i &lt;= 100000; i++) &#123;        userService.save(buildUser(i));    &#125;    long e = System.currentTimeMillis();    System.out.println(&quot;耗时：&quot; + (e - b));&#125;private User buildUser(int i) &#123;    User user = new User();    user.setUsername(&quot;user_&quot; + i);    user.setPassword(&quot;123&quot;);    user.setPhone(&quot;&quot; + (18688190000L + i));    user.setBalance(2000);    user.setInfo(&quot;&#123;\\&quot;age\\&quot;: 24, \\&quot;intro\\&quot;: \\&quot;英文老师\\&quot;, \\&quot;gender\\&quot;: \\&quot;female\\&quot;&#125;&quot;);    user.setCreateTime(LocalDateTime.now());    user.setUpdateTime(user.getCreateTime());    return user;&#125;\n\n\n\n可以看到速度非常慢。\n然后再试试MybatisPlus的批处理：\n12345678910111213141516@Testvoid testSaveBatch() &#123;    // 准备10万条数据    List&lt;User&gt; list = new ArrayList&lt;&gt;(1000);    long b = System.currentTimeMillis();    for (int i = 1; i &lt;= 100000; i++) &#123;        list.add(buildUser(i));        // 每1000条批量插入一次        if (i % 1000 == 0) &#123;            userService.saveBatch(list);            list.clear();        &#125;    &#125;    long e = System.currentTimeMillis();    System.out.println(&quot;耗时：&quot; + (e - b));&#125;\n\n执行最终耗时如下：\n可以看到使用了批处理以后，比逐条新增效率提高了10倍左右，性能还是不错的。\n不过，我们简单查看一下MybatisPlus源码：\n1234567891011121314151617181920212223@Transactional(rollbackFor = Exception.class)@Overridepublic boolean saveBatch(Collection&lt;T&gt; entityList, int batchSize) &#123;    String sqlStatement = getSqlStatement(SqlMethod.INSERT_ONE);    return executeBatch(entityList, batchSize, (sqlSession, entity) -&gt; sqlSession.insert(sqlStatement, entity));&#125;// ...SqlHelperpublic static &lt;E&gt; boolean executeBatch(Class&lt;?&gt; entityClass, Log log, Collection&lt;E&gt; list, int batchSize, BiConsumer&lt;SqlSession, E&gt; consumer) &#123;    Assert.isFalse(batchSize &lt; 1, &quot;batchSize must not be less than one&quot;);    return !CollectionUtils.isEmpty(list) &amp;&amp; executeBatch(entityClass, log, sqlSession -&gt; &#123;        int size = list.size();        int idxLimit = Math.min(batchSize, size);        int i = 1;        for (E element : list) &#123;            consumer.accept(sqlSession, element);            if (i == idxLimit) &#123;                sqlSession.flushStatements();                idxLimit = Math.min(idxLimit + batchSize, size);            &#125;            i++;        &#125;    &#125;);&#125;\n\n可以发现其实MybatisPlus的批处理是基于PrepareStatement的预编译模式，然后批量提交，最终在数据库执行时还是会有多条insert语句，逐条插入数据。SQL类似这样：\n1234Preparing: INSERT INTO user ( username, password, phone, info, balance, create_time, update_time ) VALUES ( ?, ?, ?, ?, ?, ?, ? )Parameters: user_1, 123, 18688190001, &quot;&quot;, 2000, 2023-07-01, 2023-07-01Parameters: user_2, 123, 18688190002, &quot;&quot;, 2000, 2023-07-01, 2023-07-01Parameters: user_3, 123, 18688190003, &quot;&quot;, 2000, 2023-07-01, 2023-07-01\n\n而如果想要得到最佳性能，最好是将多条SQL合并为一条，像这样：\n123456INSERT INTO user ( username, password, phone, info, balance, create_time, update_time )VALUES (user_1, 123, 18688190001, &quot;&quot;, 2000, 2023-07-01, 2023-07-01),(user_2, 123, 18688190002, &quot;&quot;, 2000, 2023-07-01, 2023-07-01),(user_3, 123, 18688190003, &quot;&quot;, 2000, 2023-07-01, 2023-07-01),(user_4, 123, 18688190004, &quot;&quot;, 2000, 2023-07-01, 2023-07-01);\n\n该怎么做呢？\nMySQL的客户端连接参数中有这样的一个参数：rewriteBatchedStatements。顾名思义，就是重写批处理的statement语句。参考文档：\nhttps://dev.mysql.com/doc/connector-j/8.0/en/connector-j-connp-props-performance-extensions.html#cj-conn-prop_rewriteBatchedStatements\n这个参数的默认值是false，我们需要修改连接参数，将其配置为true\n修改项目中的application.yml文件，在jdbc的url后面添加参数&amp;rewriteBatchedStatements=true:\n123456spring:  datasource:    url: jdbc:mysql://127.0.0.1:3306/mp?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;serverTimezone=Asia/Shanghai&amp;rewriteBatchedStatements=true    driver-class-name: com.mysql.cj.jdbc.Driver    username: root    password: MySQL123\n\n再次测试插入10万条数据，可以发现速度有非常明显的提升：\n在ClientPreparedStatement的executeBatchInternal中，有判断rewriteBatchedStatements值是否为true并重写SQL的功能：\n最终，SQL被重写了：\n4.扩展功能4.1.代码生成在使用MybatisPlus以后，基础的Mapper、Service、PO代码相对固定，重复编写也比较麻烦。因此MybatisPlus官方提供了代码生成器根据数据库表结构生成PO、Mapper、Service等相关代码。只不过代码生成器同样要编码使用，也很麻烦。\n这里推荐大家使用一款MybatisPlus的插件，它可以基于图形化界面完成MybatisPlus的代码生成，非常简单。\n4.1.1.安装插件在Idea的plugins市场中搜索并安装MyBatisPlus插件：\n然后重启你的Idea即可使用。\n4.1.2.使用刚好数据库中还有一张address表尚未生成对应的实体和mapper等基础代码。我们利用插件生成一下。 首先需要配置数据库地址，在Idea顶部菜单中，找到other，选择Config Database：\n在弹出的窗口中填写数据库连接的基本信息：\n点击OK保存。\n然后再次点击Idea顶部菜单中的other，然后选择Code Generator:\n在弹出的表单中填写信息：\n最终，代码自动生成到指定的位置了：\n4.2.静态工具有的时候Service之间也会相互调用，为了避免出现循环依赖问题，MybatisPlus提供一个静态工具类：Db，其中的一些静态方法与IService中方法签名基本一致，也可以帮助我们实现CRUD功能：\n示例：\n12345678910111213141516171819202122@Testvoid testDbGet() &#123;    User user = Db.getById(1L, User.class);    System.out.println(user);&#125;@Testvoid testDbList() &#123;    // 利用Db实现复杂条件查询    List&lt;User&gt; list = Db.lambdaQuery(User.class)            .like(User::getUsername, &quot;o&quot;)            .ge(User::getBalance, 1000)            .list();    list.forEach(System.out::println);&#125;@Testvoid testDbUpdate() &#123;    Db.lambdaUpdate(User.class)            .set(User::getBalance, 2000)            .eq(User::getUsername, &quot;Rose&quot;);&#125;\n\n需求：改造根据id用户查询的接口，查询用户的同时返回用户收货地址列表\n首先，我们要添加一个收货地址的VO对象：\n12345678910111213141516171819202122232425262728293031323334353637383940package com.itheima.mp.domain.vo;import io.swagger.annotations.ApiModel;import io.swagger.annotations.ApiModelProperty;import lombok.Data;@Data@ApiModel(description = &quot;收货地址VO&quot;)public class AddressVO&#123;    @ApiModelProperty(&quot;id&quot;)    private Long id;    @ApiModelProperty(&quot;用户ID&quot;)    private Long userId;    @ApiModelProperty(&quot;省&quot;)    private String province;    @ApiModelProperty(&quot;市&quot;)    private String city;    @ApiModelProperty(&quot;县/区&quot;)    private String town;    @ApiModelProperty(&quot;手机&quot;)    private String mobile;    @ApiModelProperty(&quot;详细地址&quot;)    private String street;    @ApiModelProperty(&quot;联系人&quot;)    private String contact;    @ApiModelProperty(&quot;是否是默认 1默认 0否&quot;)    private Boolean isDefault;    @ApiModelProperty(&quot;备注&quot;)    private String notes;&#125;\n\n然后，改造原来的UserVO，添加一个地址属性：\n接下来，修改UserController中根据id查询用户的业务接口：\n123456@GetMapping(&quot;/&#123;id&#125;&quot;)@ApiOperation(&quot;根据id查询用户&quot;)public UserVO queryUserById(@PathVariable(&quot;id&quot;) Long userId)&#123;    // 基于自定义service方法查询    return userService.queryUserAndAddressById(userId);&#125;\n\n由于查询业务复杂，所以要在service层来实现。首先在IUserService中定义方法：\n1234567891011package com.itheima.mp.service;import com.baomidou.mybatisplus.extension.service.IService;import com.itheima.mp.domain.po.User;import com.itheima.mp.domain.vo.UserVO;public interface IUserService extends IService&lt;User&gt; &#123;    void deduct(Long id, Integer money);    UserVO queryUserAndAddressById(Long userId);&#125;\n\n然后，在UserServiceImpl中实现该方法：\n12345678910111213141516@Overridepublic UserVO queryUserAndAddressById(Long userId) &#123;    // 1.查询用户    User user = getById(userId);    if (user == null) &#123;        return null;    &#125;    // 2.查询收货地址    List&lt;Address&gt; addresses = Db.lambdaQuery(Address.class)            .eq(Address::getUserId, userId)            .list();    // 3.处理vo    UserVO userVO = BeanUtil.copyProperties(user, UserVO.class);    userVO.setAddresses(BeanUtil.copyToList(addresses, AddressVO.class));    return userVO;&#125;\n\n在查询地址时，我们采用了Db的静态方法，因此避免了注入AddressService，减少了循环依赖的风险。\n再来实现一个功能：\n\n根据id批量查询用户，并查询出用户对应的所有地址\n\n4.3.逻辑删除对于一些比较重要的数据，我们往往会采用逻辑删除的方案，即：\n\n在表中添加一个字段标记数据是否被删除\n当删除数据时把标记置为true\n查询时过滤掉标记为true的数据\n\n一旦采用了逻辑删除，所有的查询和删除逻辑都要跟着变化，非常麻烦。\n为了解决这个问题，MybatisPlus就添加了对逻辑删除的支持。\n注意，只有MybatisPlus生成的SQL语句才支持自动的逻辑删除，自定义SQL需要自己手动处理逻辑删除。\n例如，我们给address表添加一个逻辑删除字段：\n1alter table address add deleted bit default b&#x27;0&#x27; null comment &#x27;逻辑删除&#x27;;\n\n然后给Address实体添加deleted字段：\n接下来，我们要在application.yml中配置逻辑删除字段：\n123456mybatis-plus:  global-config:    db-config:      logic-delete-field: deleted # 全局逻辑删除的实体字段名(since 3.3.0,配置后可以忽略不配置步骤2)      logic-delete-value: 1 # 逻辑已删除值(默认为 1)      logic-not-delete-value: 0 # 逻辑未删除值(默认为 0)\n\n测试： 首先，我们执行一个删除操作：\n12345@Testvoid testDeleteByLogic() &#123;    // 删除方法与以前没有区别    addressService.removeById(59L);&#125;\n\n方法与普通删除一模一样，但是底层的SQL逻辑变了：\n查询一下试试：\n12345@Testvoid testQuery() &#123;    List&lt;Address&gt; list = addressService.list();    list.forEach(System.out::println);&#125;\n\n会发现id为59的确实没有查询出来，而且SQL中也对逻辑删除字段做了判断：\n综上， 开启了逻辑删除功能以后，我们就可以像普通删除一样做CRUD，基本不用考虑代码逻辑问题。还是非常方便的。\n注意： 逻辑删除本身也有自己的问题，比如：\n\n会导致数据库表垃圾数据越来越多，从而影响查询效率\nSQL中全都需要对逻辑删除字段做判断，影响查询效率\n\n因此，我不太推荐采用逻辑删除功能，如果数据不能删除，可以采用把数据迁移到其它表的办法。\n4.4.通用枚举User类中有一个用户状态字段：\n像这种字段我们一般会定义一个枚举，做业务判断的时候就可以直接基于枚举做比较。但是我们数据库采用的是int类型，对应的PO也是Integer。因此业务操作时必须手动把枚举与Integer转换，非常麻烦。\n因此，MybatisPlus提供了一个处理枚举的类型转换器，可以帮我们把枚举类型与数据库类型自动转换。\n4.4.1.定义枚举我们定义一个用户状态的枚举：\n代码如下：\n123456789101112131415161718package com.itheima.mp.enums;import com.baomidou.mybatisplus.annotation.EnumValue;import lombok.Getter;@Getterpublic enum UserStatus &#123;    NORMAL(1, &quot;正常&quot;),    FREEZE(2, &quot;冻结&quot;)    ;    private final int value;    private final String desc;    UserStatus(int value, String desc) &#123;        this.value = value;        this.desc = desc;    &#125;&#125;\n\n然后把User类中的status字段改为UserStatus 类型：\n要让MybatisPlus处理枚举与数据库类型自动转换，我们必须告诉MybatisPlus，枚举中的哪个字段的值作为数据库值。 MybatisPlus提供了@EnumValue注解来标记枚举属性：\n4.4.2.配置枚举处理器在application.yaml文件中添加配置：\n123mybatis-plus:  configuration:    default-enum-type-handler: com.baomidou.mybatisplus.core.handlers.MybatisEnumTypeHandler\n\n4.4.3.测试12345@Testvoid testService() &#123;    List&lt;User&gt; list = userService.list();    list.forEach(System.out::println);&#125;\n\n最终，查询出的User类的status字段会是枚举类型：\n同时，为了使页面查询结果也是枚举格式，我们需要修改UserVO中的status属性：\n并且，在UserStatus枚举中通过@JsonValue注解标记JSON序列化时展示的字段：\n最后，在页面查询，结果如下：\n4.5.JSON类型处理器数据库的user表中有一个info字段，是JSON类型：\n格式像这样：\n1&#123;&quot;age&quot;: 20, &quot;intro&quot;: &quot;佛系青年&quot;, &quot;gender&quot;: &quot;male&quot;&#125;\n\n而目前User实体类中却是String类型：\n这样一来，我们要读取info中的属性时就非常不方便。如果要方便获取，info的类型最好是一个Map或者实体类。\n而一旦我们把info改为对象类型，就需要在写入数据库时手动转为String，再读取数据库时，手动转换为对象，这会非常麻烦。\n因此MybatisPlus提供了很多特殊类型字段的类型处理器，解决特殊字段类型与数据库类型转换的问题。例如处理JSON就可以使用JacksonTypeHandler处理器。\n接下来，我们就来看看这个处理器该如何使用。\n4.5.1.定义实体首先，我们定义一个单独实体类来与info字段的属性匹配：\n代码如下：\n12345678910package com.itheima.mp.domain.po;import lombok.Data;@Datapublic class UserInfo &#123;    private Integer age;    private String intro;    private String gender;&#125;\n\n4.5.2.使用类型处理器接下来，将User类的info字段修改为UserInfo类型，并声明类型处理器：\n测试可以发现，所有数据都正确封装到UserInfo当中了：\n同时，为了让页面返回的结果也以对象格式返回，我们要修改UserVO中的info字段：\n此时，在页面查询结果如下：\n4.6.配置加密（选学）目前我们配置文件中的很多参数都是明文，如果开发人员发生流动，很容易导致敏感信息的泄露。所以MybatisPlus支持配置文件的加密和解密功能。\n我们以数据库的用户名和密码为例。\n4.6.1.生成秘钥首先，我们利用AES工具生成一个随机秘钥，然后对用户名、密码加密：\n12345678910111213141516171819202122package com.itheima.mp;import com.baomidou.mybatisplus.core.toolkit.AES;import org.junit.jupiter.api.Test;class MpDemoApplicationTests &#123;    @Test    void contextLoads() &#123;        // 生成 16 位随机 AES 密钥        String randomKey = AES.generateRandomKey();        System.out.println(&quot;randomKey = &quot; + randomKey);        // 利用密钥对用户名加密        String username = AES.encrypt(&quot;root&quot;, randomKey);        System.out.println(&quot;username = &quot; + username);        // 利用密钥对用户名加密        String password = AES.encrypt(&quot;MySQL123&quot;, randomKey);        System.out.println(&quot;password = &quot; + password);    &#125;&#125;\n\n打印结果如下：\n123randomKey = 6234633a66fb399fusername = px2bAbnUfiY8K/IgsKvscg==password = FGvCSEaOuga3ulDAsxw68Q==\n\n4.6.2.修改配置修改application.yaml文件，把jdbc的用户名、密码修改为刚刚加密生成的密文：\n123456spring:  datasource:    url: jdbc:mysql://127.0.0.1:3306/mp?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;serverTimezone=Asia/Shanghai&amp;rewriteBatchedStatements=true    driver-class-name: com.mysql.cj.jdbc.Driver    username: mpw:QWWVnk1Oal3258x5rVhaeQ== # 密文要以 mpw:开头    password: mpw:EUFmeH3cNAzdRGdOQcabWg== # 密文要以 mpw:开头\n\n4.6.3.测试在启动项目的时候，需要把刚才生成的秘钥添加到启动参数中，像这样：\n–mpw.key&#x3D;6234633a66fb399f\n单元测试的时候不能添加启动参数，所以要在测试类的注解上配置：\n然后随意运行一个单元测试，可以发现数据库查询正常。\n5.插件功能MybatisPlus提供了很多的插件功能，进一步拓展其功能。目前已有的插件有：\n\nPaginationInnerInterceptor：自动分页\nTenantLineInnerInterceptor：多租户\nDynamicTableNameInnerInterceptor：动态表名\nOptimisticLockerInnerInterceptor：乐观锁\nIllegalSQLInnerInterceptor：sql 性能规范\nBlockAttackInnerInterceptor：防止全表更新与删除\n\n注意： 使用多个分页插件的时候需要注意插件定义顺序，建议使用顺序如下：\n\n多租户,动态表名\n分页,乐观锁\nsql 性能规范,防止全表更新与删除\n\n这里我们以分页插件为里来学习插件的用法。\n5.1.分页插件在未引入分页插件的情况下，MybatisPlus是不支持分页功能的，IService和BaseMapper中的分页方法都无法正常起效。 所以，我们必须配置分页插件。\n5.1.1.配置分页插件在项目中新建一个配置类：\n其代码如下：\n1234567891011121314151617181920package com.itheima.mp.config;import com.baomidou.mybatisplus.annotation.DbType;import com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;import com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configurationpublic class MybatisConfig &#123;    @Bean    public MybatisPlusInterceptor mybatisPlusInterceptor() &#123;        // 初始化核心插件        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();        // 添加分页插件        interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL));        return interceptor;    &#125;&#125;\n\n5.1.2.分页API编写一个分页查询的测试：\n123456789101112@Testvoid testPageQuery() &#123;    // 1.分页查询，new Page()的两个参数分别是：页码、每页大小    Page&lt;User&gt; p = userService.page(new Page&lt;&gt;(2, 2));    // 2.总条数    System.out.println(&quot;total = &quot; + p.getTotal());    // 3.总页数    System.out.println(&quot;pages = &quot; + p.getPages());    // 4.数据    List&lt;User&gt; records = p.getRecords();    records.forEach(System.out::println);&#125;\n\n运行的SQL如下：\n这里用到了分页参数，Page，即可以支持分页参数，也可以支持排序参数。常见的API如下：\n1234567int pageNo = 1, pageSize = 5;// 分页参数Page&lt;User&gt; page = Page.of(pageNo, pageSize);// 排序参数, 通过OrderItem来指定page.addOrder(new OrderItem(&quot;balance&quot;, false));userService.page(page);\n\n5.2.通用分页实体现在要实现一个用户分页查询的接口，接口规范如下：\n\n\n\n参数\n说明\n\n\n\n请求方式\nGET\n\n\n请求路径\n&#x2F;users&#x2F;page\n\n\n请求参数\n&#123;    &quot;pageNo&quot;: 1,    &quot;pageSize&quot;: 5,    &quot;sortBy&quot;: &quot;balance&quot;,    &quot;isAsc&quot;: false,    &quot;name&quot;: &quot;o&quot;,    &quot;status&quot;: 1 &#125;\n\n\n返回值\n&#123;    &quot;total&quot;: 100006,    &quot;pages&quot;: 50003,    &quot;list&quot;: [        &#123;            &quot;id&quot;: 1685100878975279298,            &quot;username&quot;: &quot;user_9****&quot;,            &quot;info&quot;: &#123;                &quot;age&quot;: 24,                &quot;intro&quot;: &quot;英文老师&quot;,                &quot;gender&quot;: &quot;female&quot;            &#125;,            &quot;status&quot;: &quot;正常&quot;,            &quot;balance&quot;: 2000        &#125;    ] &#125;\n\n\n特殊说明\n如果排序字段为空，默认按照更新时间排序排序字段不为空，则按照排序字段排序\n\n\n这里需要定义3个实体：\n\nUserQuery：分页查询条件的实体，包含分页、排序参数、过滤条件\nPageDTO：分页结果实体，包含总条数、总页数、当前页数据\nUserVO：用户页面视图实体\n\n5.2.1.实体由于UserQuery之前已经定义过了，并且其中已经包含了过滤条件，具体代码如下：\n123456789101112131415161718package com.itheima.mp.domain.query;import io.swagger.annotations.ApiModel;import io.swagger.annotations.ApiModelProperty;import lombok.Data;@Data@ApiModel(description = &quot;用户查询条件实体&quot;)public class UserQuery &#123;    @ApiModelProperty(&quot;用户名关键字&quot;)    private String name;    @ApiModelProperty(&quot;用户状态：1-正常，2-冻结&quot;)    private Integer status;    @ApiModelProperty(&quot;余额最小值&quot;)    private Integer minBalance;    @ApiModelProperty(&quot;余额最大值&quot;)    private Integer maxBalance;&#125;\n\n其中缺少的仅仅是分页条件，而分页条件不仅仅用户分页查询需要，以后其它业务也都有分页查询的需求。因此建议将分页查询条件单独定义为一个PageQuery实体：\nPageQuery是前端提交的查询参数，一般包含四个属性：\n\npageNo：页码\npageSize：每页数据条数\nsortBy：排序字段\nisAsc：是否升序\n\n123456789101112@Data@ApiModel(description = &quot;分页查询实体&quot;)public class PageQuery &#123;    @ApiModelProperty(&quot;页码&quot;)    private Long pageNo;    @ApiModelProperty(&quot;页码&quot;)    private Long pageSize;    @ApiModelProperty(&quot;排序字段&quot;)    private String sortBy;    @ApiModelProperty(&quot;是否升序&quot;)    private Boolean isAsc;&#125;\n\n然后，让我们的UserQuery继承这个实体：\n1234567891011121314151617181920package com.itheima.mp.domain.query;import io.swagger.annotations.ApiModel;import io.swagger.annotations.ApiModelProperty;import lombok.Data;import lombok.EqualsAndHashCode;@EqualsAndHashCode(callSuper = true)@Data@ApiModel(description = &quot;用户查询条件实体&quot;)public class UserQuery extends PageQuery &#123;    @ApiModelProperty(&quot;用户名关键字&quot;)    private String name;    @ApiModelProperty(&quot;用户状态：1-正常，2-冻结&quot;)    private Integer status;    @ApiModelProperty(&quot;余额最小值&quot;)    private Integer minBalance;    @ApiModelProperty(&quot;余额最大值&quot;)    private Integer maxBalance;&#125;\n\n返回值的用户实体沿用之前定一个UserVO实体：\n最后，则是分页实体PageDTO:\n代码如下：\n123456789101112131415161718package com.itheima.mp.domain.dto;import io.swagger.annotations.ApiModel;import io.swagger.annotations.ApiModelProperty;import lombok.Data;import java.util.List;@Data@ApiModel(description = &quot;分页结果&quot;)public class PageDTO&lt;T&gt; &#123;    @ApiModelProperty(&quot;总条数&quot;)    private Long total;    @ApiModelProperty(&quot;总页数&quot;)    private Long pages;    @ApiModelProperty(&quot;集合&quot;)    private List&lt;T&gt; list;&#125;\n\n5.2.2.开发接口我们在UserController中定义分页查询用户的接口：\n12345678910111213141516171819202122232425package com.itheima.mp.controller;import com.itheima.mp.domain.dto.PageDTO;import com.itheima.mp.domain.query.PageQuery;import com.itheima.mp.domain.vo.UserVO;import com.itheima.mp.service.UserService;import lombok.RequiredArgsConstructor;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestController@RequestMapping(&quot;users&quot;)@RequiredArgsConstructorpublic class UserController &#123;    private final UserService userService;    @GetMapping(&quot;/page&quot;)    public PageDTO&lt;UserVO&gt; queryUsersPage(UserQuery query)&#123;        return userService.queryUsersPage(query);    &#125;    // 。。。 略&#125;\n\n然后在IUserService中创建queryUsersPage方法：\n1PageDTO&lt;UserVO&gt; queryUsersPage(PageQuery query);\n\n接下来，在UserServiceImpl中实现该方法：\n12345678910111213141516171819202122232425@Overridepublic PageDTO&lt;UserVO&gt; queryUsersPage(PageQuery query) &#123;    // 1.构建条件    // 1.1.分页条件    Page&lt;User&gt; page = Page.of(query.getPageNo(), query.getPageSize());    // 1.2.排序条件    if (query.getSortBy() != null) &#123;        page.addOrder(new OrderItem(query.getSortBy(), query.getIsAsc()));    &#125;else&#123;        // 默认按照更新时间排序        page.addOrder(new OrderItem(&quot;update_time&quot;, false));    &#125;    // 2.查询    page(page);    // 3.数据非空校验    List&lt;User&gt; records = page.getRecords();    if (records == null || records.size() &lt;= 0) &#123;        // 无数据，返回空结果        return new PageDTO&lt;&gt;(page.getTotal(), page.getPages(), Collections.emptyList());    &#125;    // 4.有数据，转换    List&lt;UserVO&gt; list = BeanUtil.copyToList(records, UserVO.class);    // 5.封装返回    return new PageDTO&lt;UserVO&gt;(page.getTotal(), page.getPages(), list);&#125;\n\n启动项目，在页面查看：\n5.2.3.改造PageQuery实体在刚才的代码中，从PageQuery到MybatisPlus的Page之间转换的过程还是比较麻烦的。\n我们完全可以在PageQuery这个实体中定义一个工具方法，简化开发。 像这样：\n1234567891011121314151617181920212223242526272829303132333435363738394041package com.itheima.mp.domain.query;import com.baomidou.mybatisplus.core.metadata.OrderItem;import com.baomidou.mybatisplus.extension.plugins.pagination.Page;import lombok.Data;@Datapublic class PageQuery &#123;    private Integer pageNo;    private Integer pageSize;    private String sortBy;    private Boolean isAsc;    public &lt;T&gt;  Page&lt;T&gt; toMpPage(OrderItem ... orders)&#123;        // 1.分页条件        Page&lt;T&gt; p = Page.of(pageNo, pageSize);        // 2.排序条件        // 2.1.先看前端有没有传排序字段        if (sortBy != null) &#123;            p.addOrder(new OrderItem(sortBy, isAsc));            return p;        &#125;        // 2.2.再看有没有手动指定排序字段        if(orders != null)&#123;            p.addOrder(orders);        &#125;        return p;    &#125;    public &lt;T&gt; Page&lt;T&gt; toMpPage(String defaultSortBy, boolean isAsc)&#123;        return this.toMpPage(new OrderItem(defaultSortBy, isAsc));    &#125;    public &lt;T&gt; Page&lt;T&gt; toMpPageDefaultSortByCreateTimeDesc() &#123;        return toMpPage(&quot;create_time&quot;, false);    &#125;    public &lt;T&gt; Page&lt;T&gt; toMpPageDefaultSortByUpdateTimeDesc() &#123;        return toMpPage(&quot;update_time&quot;, false);    &#125;&#125;\n\n这样我们在开发也时就可以省去对从PageQuery到Page的的转换：\n12// 1.构建条件Page&lt;User&gt; page = query.toMpPageDefaultSortByCreateTimeDesc();\n\n5.2.4.改造PageDTO实体在查询出分页结果后，数据的非空校验，数据的vo转换都是模板代码，编写起来很麻烦。\n我们完全可以将其封装到PageDTO的工具方法中，简化整个过程：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package com.itheima.mp.domain.dto;import cn.hutool.core.bean.BeanUtil;import com.baomidou.mybatisplus.extension.plugins.pagination.Page;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;import java.util.Collections;import java.util.List;import java.util.function.Function;import java.util.stream.Collectors;@Data@NoArgsConstructor@AllArgsConstructorpublic class PageDTO&lt;V&gt; &#123;    private Long total;    private Long pages;    private List&lt;V&gt; list;    /**     * 返回空分页结果     * @param p MybatisPlus的分页结果     * @param &lt;V&gt; 目标VO类型     * @param &lt;P&gt; 原始PO类型     * @return VO的分页对象     */    public static &lt;V, P&gt; PageDTO&lt;V&gt; empty(Page&lt;P&gt; p)&#123;        return new PageDTO&lt;&gt;(p.getTotal(), p.getPages(), Collections.emptyList());    &#125;    /**     * 将MybatisPlus分页结果转为 VO分页结果     * @param p MybatisPlus的分页结果     * @param voClass 目标VO类型的字节码     * @param &lt;V&gt; 目标VO类型     * @param &lt;P&gt; 原始PO类型     * @return VO的分页对象     */    public static &lt;V, P&gt; PageDTO&lt;V&gt; of(Page&lt;P&gt; p, Class&lt;V&gt; voClass) &#123;        // 1.非空校验        List&lt;P&gt; records = p.getRecords();        if (records == null || records.size() &lt;= 0) &#123;            // 无数据，返回空结果            return empty(p);        &#125;        // 2.数据转换        List&lt;V&gt; vos = BeanUtil.copyToList(records, voClass);        // 3.封装返回        return new PageDTO&lt;&gt;(p.getTotal(), p.getPages(), vos);    &#125;    /**     * 将MybatisPlus分页结果转为 VO分页结果，允许用户自定义PO到VO的转换方式     * @param p MybatisPlus的分页结果     * @param convertor PO到VO的转换函数     * @param &lt;V&gt; 目标VO类型     * @param &lt;P&gt; 原始PO类型     * @return VO的分页对象     */    public static &lt;V, P&gt; PageDTO&lt;V&gt; of(Page&lt;P&gt; p, Function&lt;P, V&gt; convertor) &#123;        // 1.非空校验        List&lt;P&gt; records = p.getRecords();        if (records == null || records.size() &lt;= 0) &#123;            // 无数据，返回空结果            return empty(p);        &#125;        // 2.数据转换        List&lt;V&gt; vos = records.stream().map(convertor).collect(Collectors.toList());        // 3.封装返回        return new PageDTO&lt;&gt;(p.getTotal(), p.getPages(), vos);    &#125;&#125;\n\n最终，业务层的代码可以简化为：\n123456789@Overridepublic PageDTO&lt;UserVO&gt; queryUserByPage(PageQuery query) &#123;    // 1.构建条件    Page&lt;User&gt; page = query.toMpPageDefaultSortByCreateTimeDesc();    // 2.查询    page(page);    // 3.封装返回    return PageDTO.of(page, UserVO.class);&#125;\n\n如果是希望自定义PO到VO的转换过程，可以这样做：\n12345678910111213141516@Overridepublic PageDTO&lt;UserVO&gt; queryUserByPage(PageQuery query) &#123;    // 1.构建条件    Page&lt;User&gt; page = query.toMpPageDefaultSortByCreateTimeDesc();    // 2.查询    page(page);    // 3.封装返回    return PageDTO.of(page, user -&gt; &#123;        // 拷贝属性到VO        UserVO vo = BeanUtil.copyProperties(user, UserVO.class);        // 用户名脱敏        String username = vo.getUsername();        vo.setUsername(username.substring(0, username.length() - 2) + &quot;**&quot;);        return vo;    &#125;);&#125;\n\n最终查询的结果如下：\n","slug":"MybatisPlus","date":"2024-09-20T12:19:36.839Z","categories_index":"SpringCloud","tags_index":"java后端,MybatisPlus","author_index":"神秘奇男子"},{"id":"6567def797e3574f535ec70b74f4992c","title":"Linux常用命令-2","content":"Linux常用命令-2\n\n\n\n\n\n\n\n\n转载修改自黑马Linux学习笔记，持续修改补充中\nLinux的目录结构\n\n/，根目录是最顶级的目录了\nLinux只有一个顶级目录：/\n路径描述的层次关系同样适用/来表示\n&#x2F;home&#x2F;itheima&#x2F;a.txt，表示根目录下的home文件夹内有itheima文件夹，内有a.txt\n\nls命令功能：列出文件夹信息\n语法：ls [-l -h -a] [参数]\n\n参数：被查看的文件夹，不提供参数，表示查看当前工作目录\n-l，以列表形式查看\n-h，配合-l，以更加人性化的方式显示文件大小\n-a，显示隐藏文件\n\n隐藏文件、文件夹在Linux中以.开头的，均是隐藏的。\n默认不显示出来，需要-a选项才可查看到。\npwd命令功能：展示当前工作目录\n语法：pwd\ncd命令功能：切换工作目录\n语法：cd [目标目录]\n参数：目标目录，要切换去的地方，不提供默认切换到当前登录用户HOME目录\nHOME目录每一个用户在Linux系统中都有自己的专属工作目录，称之为HOME目录。\n\n普通用户的HOME目录，默认在：/home/用户名\n\nroot用户的HOME目录，在：/root\n\n\nFinalShell登陆终端后，默认的工作目录就是用户的HOME目录\n相对路径、绝对路径\n相对路径，&#x3D;&#x3D;非&#x3D;&#x3D;/开头的称之为相对路径\n相对路径表示以当前目录作为起点，去描述路径，如test/a.txt，表示当前工作目录内的test文件夹内的a.txt文件\n\n绝对路径，&#x3D;&#x3D;以&#x3D;&#x3D;/开头的称之为绝对路径\n绝对路径从根开始描述路径\n\n\n特殊路径符\n.，表示当前，比如.&#x2F;a.txt，表示当前文件夹内的a.txt文件\n..，表示上级目录，比如../表示上级目录，../../表示上级的上级目录\n~，表示用户的HOME目录，比如cd ~，即可切回用户HOME目录\n\nmkdir命令功能：创建文件夹\n语法：mkdir [-p] 参数\n\n参数：被创建文件夹的路径\n选项：-p，可选，表示创建前置路径\n\ntouch命令功能：创建文件\n语法：touch 参数\n\n参数：被创建的文件路径\n\ncat命令功能：查看文件内容\n语法：cat 参数\n\n参数：被查看的文件路径\n\nmore命令功能：查看文件，可以支持翻页查看\n语法：more 参数\n\n参数：被查看的文件路径\n在查看过程中：\n空格键翻页\nq退出查看\n\n\n\ncp命令功能：复制文件、文件夹\n语法：cp [-r] 参数1 参数2\n\n参数1，被复制的\n参数2，要复制去的地方\n选项：-r，可选，复制文件夹使用\n\n示例：\n\ncp a.txt b.txt，复制当前目录下a.txt为b.txt\ncp a.txt test&#x2F;，复制当前目录a.txt到test文件夹内\ncp -r test test2，复制文件夹test到当前文件夹内为test2存在\n\nmv命令功能：移动文件、文件夹\n语法：mv 参数1 参数2\n\n参数1：被移动的\n参数2：要移动去的地方，参数2如果不存在，则会进行改名\n\nrm命令功能：删除文件、文件夹\n语法：rm [-r -f] 参数...参数\n\n参数：支持多个，每一个表示被删除的，空格进行分隔\n选项：-r，删除文件夹使用\n选项：-f，强制删除，不会给出确认提示，一般root用户会用到\n\n\n\n\n\n\n\n\n\n\nrm命令很危险，一定要注意，特别是切换到root用户的时候。\nwhich命令功能：查看命令的程序本体文件路径\n语法：which 参数\n\n参数：被查看的命令\n\nfind命令功能：搜索文件\n语法1按文件名搜索：find 路径 -name 参数\n\n路径，搜索的起始路径\n参数，搜索的关键字，支持通配符*， 比如：*test表示搜索任意以test结尾的文件\n\ngrep命令功能：过滤关键字\n语法：grep [-n] 关键字 文件路径\n\n选项-n，可选，表示在结果中显示匹配的行的行号。\n参数，关键字，必填，表示过滤的关键字，带有空格或其它特殊符号，建议使用””将关键字包围起来\n参数，文件路径，必填，表示要过滤内容的文件路径，可作为内容输入端口\n\n\n\n\n\n\n\n\n\n\n参数文件路径，可以作为管道符的输入\nwc命令功能：统计\n语法：wc [-c -m -l -w] 文件路径\n\n选项，-c，统计bytes数量\n选项，-m，统计字符数量\n选项，-l，统计行数\n选项，-w，统计单词数量\n参数，文件路径，被统计的文件，可作为内容输入端口\n\n\n\n\n\n\n\n\n\n\n参数文件路径，可作为管道符的输入\n管道符|写法：|\n功能：将符号左边的结果，作为符号右边的输入\n示例：\ncat a.txt | grep itheima，将cat a.txt的结果，作为grep命令的输入，用来过滤itheima关键字\n可以支持嵌套：\ncat a.txt | grep itheima | grep itcast\necho命令功能：输出内容\n语法：echo 参数\n\n参数：被输出的内容\n\n&#96;反引号功能：被两个反引号包围的内容，会作为命令执行\n示例：\n\necho `pwd`，会输出当前工作目录\n\ntail命令功能：查看文件尾部内容\n语法：tail [-f] 参数\n\n参数：被查看的文件\n选项：-f，持续跟踪文件修改\n\nhead命令功能：查看文件头部内容\n语法：head [-n] 参数\n\n参数：被查看的文件\n选项：-n，查看的行数\n\n重定向符功能：将符号左边的结果，输出到右边指定的文件中去\n\n&gt;，表示覆盖输出\n&gt;&gt;，表示追加输出\n\nvi编辑器命令模式快捷键\n\n\n底线命令快捷键\n命令的选项我们学习的一系列Linux命令，它们所拥有的选项都是非常多的。\n比如，简单的ls命令就有：-a -A -b -c -C -d -D -f -F -g -G -h -H -i -I -k -l -L -m -n -N -o -p -q -Q -r-R -s -S -t -T -u -U -v -w -x -X -1等选项，可以发现选项是极其多的。\n课程中， 并不会将全部的选项都进行讲解，否则，一个ls命令就可能讲解2小时之久。\n课程中，会对常见的选项进行讲解， 足够满足绝大多数的学习、工作场景。\n查看命令的帮助可以通过：命令 --help查看命令的帮助手册\n\n查看命令的详细手册可以通过：man 命令查看某命令的详细手册\n\nLinux常用操作软件安装\nCentOS系统使用：\nyum [install remove search] [-y] 软件名称\ninstall 安装\nremove 卸载\nsearch 搜索\n-y，自动确认\n\n\n\n\nUbuntu系统使用\napt [install remove search] [-y] 软件名称\ninstall 安装\nremove 卸载\nsearch 搜索\n-y，自动确认\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nyum 和 apt 均需要root权限\nsystemctl功能：控制系统服务的启动关闭等\n语法：systemctl start | stop | restart | disable | enable | status 服务名\n\nstart，启动\nstop，停止\nstatus，查看状态\ndisable，关闭开机自启\nenable，开启开机自启\nrestart，重启\n\n软链接功能：创建文件、文件夹软链接（快捷方式）\n语法：ln -s 参数1 参数2\n\n参数1：被链接的\n参数2：要链接去的地方（快捷方式的名称和存放位置）\n\n日期语法：date [-d] [+格式化字符串]\n\n-d 按照给定的字符串显示日期，一般用于日期计算\n\n格式化字符串：通过特定的字符串标记，来控制显示的日期格式\n\n%Y   年%y   年份后两位数字 (00..99)\n%m   月份 (01..12)\n%d   日 (01..31)\n%H   小时 (00..23)\n%M   分钟 (00..59)\n%S   秒 (00..60)\n%s   自 1970-01-01 00:00:00 UTC 到现在的秒数\n\n\n\n示例：\n\n按照2022-01-01的格式显示日期\n\n\n按照2022-01-01 10:00:00的格式显示日期\n\n\n-d选项日期计算\n\n\n支持的时间标记为：\n\n\n\n\n\n时区修改时区为中国时区\n\nntp功能：同步时间\n安装：yum install -y ntp\n启动管理：systemctl start | stop | restart | status | disable | enable ntpd\n手动校准时间：ntpdate -u ntp.aliyun.com\nip地址格式：a.b.c.d\n\nabcd为0~255的数字\n\n特殊IP：\n\n127.0.0.1，表示本机\n0.0.0.0\n可以表示本机\n也可以表示任意IP（看使用场景）\n\n\n\n查看ip：ifconfig\n主机名功能：Linux系统的名称\n查看：hostname\n设置：hostnamectl set-hostname 主机名\n配置VMware固定IP\n修改VMware网络，参阅PPT，图太多\n\n设置Linux内部固定IP\n修改文件：/etc/sysconfig/network-scripts/ifcfg-ens33\n示例文件内容：\n12345678910111213141516171819TYPE=&quot;Ethernet&quot;PROXY_METHOD=&quot;none&quot;BROWSER_ONLY=&quot;no&quot;BOOTPROTO=&quot;static&quot;\t\t\t# 改为static，固定IPDEFROUTE=&quot;yes&quot;IPV4_FAILURE_FATAL=&quot;no&quot;IPV6INIT=&quot;yes&quot;IPV6_AUTOCONF=&quot;yes&quot;IPV6_DEFROUTE=&quot;yes&quot;IPV6_FAILURE_FATAL=&quot;no&quot;IPV6_ADDR_GEN_MODE=&quot;stable-privacy&quot;NAME=&quot;ens33&quot;UUID=&quot;1b0011cb-0d2e-4eaa-8a11-af7d50ebc876&quot;DEVICE=&quot;ens33&quot;ONBOOT=&quot;yes&quot;IPADDR=&quot;192.168.88.131&quot;\t\t# IP地址，自己设置，要匹配网络范围NETMASK=&quot;255.255.255.0&quot;\t\t# 子网掩码，固定写法255.255.255.0GATEWAY=&quot;192.168.88.2&quot;\t\t# 网关，要和VMware中配置的一致DNS1=&quot;192.168.88.2&quot;\t\t\t# DNS1服务器，和网关一致即可\n\nps命令功能：查看进程信息\n语法：ps -ef，查看全部进程信息，可以搭配grep做过滤：ps -ef | grep xxx\nkill命令\nnmap命令\nnetstat命令功能：查看端口占用\n用法：netstat -anp | grep xxx\nping命令测试网络是否联通\n语法：ping [-c num] 参数\n\nwget命令\ncurl命令\n\ntop命令功能：查看主机运行状态\n语法：top，查看基础信息\n可用选项：\n\n交互式模式中，可用快捷键：\n\ndf命令查看磁盘占用\n\niostat命令查看CPU、磁盘的相关信息\n\n\nsar命令查看网络统计\n\n环境变量\n临时设置：export 变量名&#x3D;变量值\n永久设置：\n针对用户，设置用户HOME目录内：.bashrc文件\n针对全局，设置/etc/profile\n\n\n\nPATH变量记录了执行程序的搜索路径\n可以将自定义路径加入PATH内，实现自定义命令在任意地方均可执行的效果\n$符号可以取出指定的环境变量的值\n语法：$变量名\n示例：\necho $PATH，输出PATH环境变量的值\necho $&#123;PATH&#125;ABC，输出PATH环境变量的值以及ABC\n如果变量名和其它内容混淆在一起，可以使用${}\n压缩解压压缩tar -zcvf 压缩包 被压缩1...被压缩2...被压缩N\n\n-z表示使用gzip，可以不写\n\nzip [-r] 参数1 参数2 参数N\n\n解压tar -zxvf 被解压的文件 -C 要解压去的地方\n\n-z表示使用gzip，可以省略\n-C，可以省略，指定要解压去的地方，不写解压到当前目录\n\nunzip [-d] 参数\n\nsu命令切换用户\n语法：su [-] [用户]\n\nsudo命令\n比如：\n1itheima ALL=(ALL)       NOPASSWD: ALL\n\n在visudo内配置如上内容，可以让itheima用户，无需密码直接使用sudo\nchmod命令修改文件、文件夹权限\n语法：chmod [-R] 权限 参数\n\n权限，要设置的权限，比如755，表示：rwxr-xr-x\n\n\n参数，被修改的文件、文件夹\n\n选项-R，设置文件夹和其内部全部内容一样生效\n\n\nchown命令修改文件、文件夹所属用户、组\n语法：chown [-R] [用户][:][用户组] 文件或文件夹\n\n用户组管理\n用户管理\ngenenv命令\ngetenv group，查看系统全部的用户组\n\n\ngetenv passwd，查看系统全部的用户\n\n\n\nenv命令查看系统全部的环境变量\n语法：env\n","slug":"Linux课程笔记","date":"2024-09-09T14:32:36.513Z","categories_index":"Linux","tags_index":"常用操作","author_index":"神秘奇男子"},{"id":"c25ac72fe97fa8d9f8252ec05550a8eb","title":"Linux常用命令-1","content":"Linux常用命令-1\n\n\n\n\n\n\n\n\n内容修改自github博主arkingc，持续修改补充中\n\n\n\n一.文件管理\n1.文件查找：find\n2.文件拷贝：cp\n3.打包解包：tar\n\n\n二.文本处理\n1.(显示行号)查看文件：nl\n2.文本查找：grep\n3.排序：sort\n4.转换：tr\n5.切分文本：cut\n6.拼接文本：paste\n7.统计：wc\n8.数据处理：sed\n9.数据处理：awk\n\n\n三.性能分析\n1.进程查询：ps\n2.进程监控：top\n3.打开文件查询：lsof\n4.内存使用量：free\n5.shell进程的资源限制：ulimit\n\n\n四.网络工具\n1.网卡配置：ifconfig\n2.查看当前网络连接：netstat\n3.查看路由表：route\n4.检查网络连通性：ping\n5.转发路径：traceroute\n6.网络Debug分析：nc\n7.命令行抓包：tcpdump\n8.域名解析工具：dig\n9.网络请求：curl\n\n\n五.开发及调试\n1.编辑器：vim\n2.编译器：gcc和g++\n3.调试工具：gdb\n4.查看依赖库：ldd\n5.二进制文件分析：objdump\n6.ELF文件格式分析：readelf\n7.跟踪进程中系统调用：strace\n8.跟踪进程栈：pstack\n9.进程内存映射：pmap\n\n\n六.其他\n1.终止进程：kill\n2.修改文件权限：chmod\n3.创建链接：ln\n4.显示文件尾：tail\n5.版本控制：git\n6.设置别名：alias  \n\n\n\n\n\n一.文件管理1.文件查找：find使用方法123456789101112131415find [查找目录] [查找条件]查找目录：    .：在当前目录及子目录下查找（默认）    A：在目录A及A的子目录下查找查找条件：    -name：根据文件名查找    -regex：使用正则表达式匹配    -type：按类型查找（f:文件，d:目录，l:链接...）    -atime：按访问时间查找（n:n天前的一天内，+n:n天前(不含n天本身)，-n:n天内(不含n天)）    -mtime：按修改时间查找（n:n天前的一天内，+n:n天前(不含n天本身)，-n:n天内(不含n天)）    -size：按大小查找（单位k，+nk:&quot;比nk更大&quot;，-nk:&quot;比nk更小&quot;）    -perm：按权限查找（644：权限等于644的文件）    -user/-nouser：用户名等于/用户名不等于    -group/-nogroup：组名等于/组名不等于\n\n示例12345#1.在当前目录及子目录下查找后缀为cpp的文件find . -name *.cpp#2.使用正则表达式查找find -regex &quot;.*.cpp$&quot;\n\n\n\n\n\n2.文件拷贝：cp使用方法123456cp [选项] 源路径 目的路径选项：    -a：将所有属性一起复制（包括拥有者、时间等信息）    -i：目标文件存在时，进行询问    -r：递归复制\n\n3.打包解包：tar使用方法1234567tar [-j|-z] [cv] [-f 压缩包名] 目录tar [-j|-z] [xv] [-f 解压包名] [-C 解压路径]选项：    -c/-x：打包/解包    -j/-z：bzip2格式/gzip格式    -v：显示过程\n\n二.文本处理1.(显示行号)查看文件：nl行号计算不包括空行\n2.文本查找：grep使用方法12345678grep [选项] 模式串 文件输出 | grep [选项] 模式串选项    -e：使用多个模式串    -i：忽略大小写    -n：打印行号    -c：统计次数（一行算一次）\n\n示例12#1.在test.c中搜索包含字符串”printf“或”count“的行grep -e &quot;printf&quot; -e &quot;count&quot; test.c\n\n3.排序：sort使用方法12345678sort [选项] 文件输出 | sort [选项]选项    -d：按字典序排序（默认）    -n：按数字排序    -k：&quot;-k n&quot;表示按各行第n列进行排序    -r：反序\n\n4.转换：tr使用方法123456#set1、set2为字符集，可以是单个字符，也可以是字符串输出 | tr [选项] set1 set2选项：    -d：删除字符    -s：字符压缩\n\n示例1234567891011#1.删除字符&#x27;:&#x27;cat /etc/passwd | tr -d &#x27;:&#x27;#2.将小写字母替换成大写字母last | tr &#x27;[a-z]&#x27; &#x27;A-Z&#x27;#3.将&#x27;a&#x27;、&#x27;b&#x27;、&#x27;c&#x27;替换成&#x27;z&#x27;cat test | tr “abc” &#x27;z&#x27;#4.将连续的&#x27;a&#x27;压缩成&#x27;b&#x27;（单个或连续出现的多个‘a’会压缩成一个‘b’）cat test | tr -s &#x27;a&#x27; &#x27;b&#x27;\n\n5.切分文本：cut使用方法1234567cut [选项] 文件输出 | cut [选项]选项：    -d：分隔符（-d &#x27;:&#x27; 以’:‘为分隔符）    -f：选择域（-f 1,2 输出分隔后第1列和第2列）    -c：字符范围（-c n-m 输出第n到m个字符。如果没有m，输出到末尾）\n\n示例12345#1.按’:‘分隔$PATH，输出第3个和第5个echo $PATH | cut -d &#x27;:&#x27; -f 3,5#2.输出export运行结果每行的第12-20个字符export | cut -c 12-20\n\n6.拼接文本：paste使用方法1234paste [选项] file1 file2选项：    -d：指定拼接时使用的分隔符（默认使用tab作为分隔符）\n\n7.统计：wc使用方法1234567wc [选项] 文件输出 | wc [选项]选项：    -c：统计字符数    -w：统计单词数    -l：统计行数\n\n8.数据处理：sed\n\n\n\n\n\n\n\n\nsed常用于一整行的处理。如果有一个100万行的文件，要在第100行加某些文字，此时由于文件太大，不适合用vim处理。因此使用sed是个很好的选择\n使用方法123456789101112131415sed [选项] &#x27;[动作]&#x27; 文件输入 | sed [选项] &#x27;[动作]&#x27;选项：    -n：安静模式，只输出sed处理过的行（否则未处理行也会输出）    -i：结果直接作用到文件（没指定时不会修改文件）    -e：在命令行模式上输入动作    -f：从文件中读取动作动作：[n1[,n2]] functionfunction:    a/i：在后插入/在前插入    d：删除    p：打印    s：替换\n\n示例123456789101112131415#1.插入nl /etc/passwd | sed &#x27;2a drink tea&#x27; #在第2行后插入一行：&quot;drink tea&quot;nl /etc/passwd | sed &#x27;2a aaa \\&gt; bbb&#x27; #在第2行后插入两行：&quot;aaa&quot;和&quot;bbb&quot;#2.删除nl /etc/passwd | sed &#x27;2,5d&#x27; #删除2~5行sed &#x27;/^$/d&#x27; ip #将ip文件中的空行删除#3.打印2~5行（安静模式，不使用安静模式2~5行会打印2次）nl /etc/passwd | sed -n &#x27;2,5p&#x27;#4.替换nl /etc/passwd | sed &#x27;2s/daemon/root/g&#x27; #将第二行的daemon替换成rootifconfig | grep &#x27;inet addr&#x27; | sed &#x27;s/^.*addr://g&#x27; #将所有开头的“inet addr:”删除\n\n9.数据处理：awk\n\n\n\n\n\n\n\n\n相比于sed常用于一整行的处理，awk则比较倾向于将一行分成数个“字段”来处理。因此，相当适合小型的数据处理\nawk处理步骤：\n\n读入第一行，并将第一行的数据填入$0,$1,$2等变量当中\n依据条件类型的限制，判断是否需要进行后面的动作\n做完所有的动作与条件类型\n若还有后续的“行”的数据，则重复1~3步，直到所有的数据都读完为止\n\n使用方法12345678910111213awk &#x27;条件类型1&#123;动作1&#125; 条件类型2&#123;动作2&#125; ...&#x27; filename输出 | awk &#x27;条件类型1&#123;动作1&#125; 条件类型2&#123;动作2&#125; ...&#x27;变量：    $0：整行    $1：按分隔符分隔后的第1列    $2：按分隔符分隔后的第2列    $k：按分隔符分隔后的第k列    NF：每一行拥有的字段数    NR：目前所处理的行数    FS：目前的分隔字符（默认是空格或tab）条件判断：&gt;、&lt;、&gt;=、&lt;=、==、!=命令分隔：使用&#x27;;&#x27;或Enter\n\n示例123456789#1.打印last -n 5结果中每行经过分隔符(默认情况下为空格或tab)分隔后的第1列和第3列last -n 5 | awk &#x27;&#123;print $1 &quot;\\t&quot; $3&#125;&#x27;#2.以&#x27;:&#x27;作为分隔符，打印第3列小于10的所有行的第1列和第3列cat /etc/passwd | awk &#x27;&#123;FS=&quot;:&quot;&#125; $3&lt;10&#123;print $1 &quot;\\t&quot; $3&#125;&#x27;      #（第一行不会处理）cat /etc/passwd | awk &#x27;BEGIN&#123;FS=&quot;:&quot;&#125; $3&lt;10&#123;print $1 &quot;\\t&quot; $3&#125;&#x27; #（第一行会处理）#3.假设test文件由3列数字组成，以空格分隔。该命令会计算每行的和然后打印awk &#x27;&#123;total=$1+$2+$3;printf &quot;%10d %10d %10d %10.2f\\n&quot;,$1,$2,$3,total&#125;&#x27; test\n\n注意上面的示例2，awk首先是读取一行，分隔后的数据填入$0,$1,$2等变量中才开始进行条件判断和执行动作。因此第一条命令在按空格或tab分隔后才将分隔符换成’:’，所以第一行显示结果不对\n三.性能分析1.进程查询：psman ps手册非常庞大，不是很好查阅，因此主要记住几个命令\n示例12345678#1.列出仅与自身环境有关的进程，最上层的父进程是允许该ps命令的bash而没有扩展到init进程中去ps -l#2.列出系统所有进程的信息ps auxps -ef    #aux会截断COMMAND列，-ef不会。aux是BSD风格，-ef是System V风格ps axjf   #以&quot;进程树&quot;的方式显示所有进程ps -lA    #输出格式同ps -l\n\n\n\nF：进程标志，说明进程的权限\n4：root权限\n1：仅能fork而不能exec\n0：既非4也非1\n\n\nS：进程的状态\nR(running)：正在运行\nS(Sleep)：可被唤醒的睡眠\nD：不可被唤醒的睡眠（通常可能在等待I&#x2F;O）\nT：停止，可能是在后台暂停\nZ(Zombie)：僵尸进程\n\n\nC：CPU使用率\nPRI&#x2F;NI：Priority&#x2F;Nice的缩写，CPU优先级(越小越高)\nADDR&#x2F;SZ&#x2F;WCHAN：内存相关，ADDR指出进程在内存的哪个部分，running进程一般显示’-‘。SZ为进程使用的内存。WCHAN表示进程当前是否运行中’-‘，当进程睡眠时，指出进程等待的事件\nTTY：进程运行的终端机\nTIME：进程用掉的CPU时间\n\n\n\nUSER：进程所属用户\n%CPU&#x2F;%MEM：进程消耗的CPU百分比和内存百分比\nVSZ：进程用掉的虚拟内存(KB)\nRSS：进程占用的固定内存(KB)\nTTY：进程运行的终端机，与终端机无关则显示’?’。tty1~tty6是本机的登陆者程序，pts&#x2F;0等表示由网络连接进主机的进程\nSTAT：进程目前的状态，与ps -l结果中的S等同\nSTART：进程启动的时间\nTIME：进程实际使用的CPU运行时间\n\n2.进程监控：top使用方法123456top [选项]选项：    -d：跟秒数指定更新间隔    -n：与-b搭配，指定需要进行几次top输出，重定向时常用    -p：指定PID，监控特定进程\n\ntop模式下的命令：\n\n**?**：显示可用的命令\nP：以CPU使用情况排序\nM：以内存使用情况排序\nN：以PID排序\nq：退出\n1：多核情况下切换CPU\n\n%Cpu(s)后面的“wa”表示I&#x2F;O wait，过高说明长时间等待I&#x2F;O，I&#x2F;O存在瓶颈\n3.打开文件查询：lsof使用方法1234567lsof [选项]选项：    -i：-i:端口号查看端口被占用的情况    -u：后跟用户名查看具体用户打开的文件    -p：后跟PID查看指定进程打开的文件    +d：后跟目录查看指定目录下被进程打开的文件，&quot;+D&quot;递归\n\n4.内存使用量：free使用方法12345free [选项]选项：    -b|-k|-m|-g：单位    -t：列出物理内存与swap的汇总情况    \n\n\n\nbuffers：主要缓存dentry和inode等元数据\ncached：主要缓存文件内容，即page cache\n- buffers&#x2F;cache：实际使用的内存。used-buffers-cached\n+ buffers&#x2F;cache：可用内存。free+buffers+cached（在内存紧张时，buffers和cached可以回收）\n\n详细结果说明\n5.shell进程的资源限制：ulimit使用方法123456ulimit [选项]       #查看ulimit [选项] 新值  #修改选项：    -a：列出shell进程的所有资源限制情况（-a命令会列出查看某一资源限制的选项参数）    ...\n\n使用ulimit修改资源限制只会对当前终端环境有效，如果想永久生效，可以修改文件/etc/security/limits.conf，该文件的内容如下；\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556# /etc/security/limits.conf##Each line describes a limit for a user in the form:##&lt;domain&gt;        &lt;type&gt;  &lt;item&gt;  &lt;value&gt;##Where:#&lt;domain&gt; can be:#        - a user name#        - a group name, with @group syntax#        - the wildcard *, for default entry#        - the wildcard %, can be also used with %group syntax,#                 for maxlogin limit#        - NOTE: group and wildcard limits are not applied to root.#          To apply a limit to the root user, &lt;domain&gt; must be#          the literal username root.##&lt;type&gt; can have the two values:#        - &quot;soft&quot; for enforcing the soft limits#        - &quot;hard&quot; for enforcing hard limits##&lt;item&gt; can be one of the following:#        - core - limits the core file size (KB)#        - data - max data size (KB)#        - fsize - maximum filesize (KB)#        - memlock - max locked-in-memory address space (KB)#        - nofile - max number of open files#        - rss - max resident set size (KB)#        - stack - max stack size (KB)#        - cpu - max CPU time (MIN)#        - nproc - max number of processes#        - as - address space limit (KB)#        - maxlogins - max number of logins for this user#        - maxsyslogins - max number of logins on the system#        - priority - the priority to run user process with#        - locks - max number of file locks the user can hold#        - sigpending - max number of pending signals#        - msgqueue - max memory used by POSIX message queues (bytes)#        - nice - max nice priority allowed to raise to values: [-20, 19]#        - rtprio - max realtime priority#        - chroot - change root to directory (Debian-specific)##&lt;domain&gt;      &lt;type&gt;  &lt;item&gt;         &lt;value&gt;##*               soft    core            0#root            hard    core            100000#*               hard    rss             10000#@student        hard    nproc           20#@faculty        soft    nproc           20#@faculty        hard    nproc           50#ftp             hard    nproc           0#ftp             -       chroot          /ftp#@student        -       maxlogins       4# End of file\n\n示例1234567891011121314151617root@068ca8da6d06:/# ulimit -acore file size          (blocks, -c) 0data seg size           (kbytes, -d) unlimitedscheduling priority             (-e) 0file size               (blocks, -f) unlimitedpending signals                 (-i) 7863max locked memory       (kbytes, -l) 82000max memory size         (kbytes, -m) unlimitedopen files                      (-n) 1048576pipe size            (512 bytes, -p) 8POSIX message queues     (bytes, -q) 819200real-time priority              (-r) 0stack size              (kbytes, -s) 8192cpu time               (seconds, -t) unlimitedmax user processes              (-u) unlimitedvirtual memory          (kbytes, -v) unlimitedfile locks                      (-x) unlimited\n\n四.网络工具1.网卡配置：ifconfig2.查看当前网络连接：netstat1234567891011netstat [选项]选项：    -a：将所有的连接、监听、Socket数据都列出来（如，默认情况下，不会列出监听状态的连接）    -t：列出tcp连接    -u：列出udp连接    -n：将连接的进程服务名称以端口号显示（如下图中Local Address会换成10.0.2.15:22）    -l：列出处于监听状态的连接    -p：添加一列，显示网络服务进程的PID（需要root权限）    -i：显示网络接口列表，可以配合ifconfig一起分析    -s：打印网络统计数据，包括某个协议下的收发包数量\n\n\n\nActive Internet connections（w&#x2F;o servers）：网络相关的连接\nRecv-Q：接收队列(已接收还未递交给应用)\nSend-Q：发送队列(接收方未确认的数据)\nLocal Address：本地IP(主机):端口(服务名)\nForeign Address：远端IP:端口\n\n\n\n\n\n\n\n\n\nRecv-Q和Send-Q通常应该为0，如果长时间不为0可能存在问题\n\n\n\nActive UNIX domain sockets（w&#x2F;o servers）：本地相关的套接字\nRefCnt：连接到此socket的进程数\nFlags：连接标识\nType：socket访问的类型\nPath：连接到此socket的相关程序的路径\n\n\n\nnetstat的10个基本用法\n3.查看路由表：route4.检查网络连通性：ping5.转发路径：traceroute6.网络Debug分析：nc7.命令行抓包：tcpdump使用方法1234sudo tcpdump [选项] ...选项：    -D/-i：查看/指定网卡\n\n示例12#抓取本地9877号端口的TCP数据包sudo tcpdump -i lo tcp port 9877\n\n下图为tcp回射服务器，客户端分别键入”hello”和“world”时，使用tcpdump抓取到的数据包\n  \n\n8.域名解析工具：dig9.网络请求：curl五.开发及调试1.编辑器：vim1.1 Linux vi&#x2F;vim所有的 Unix Like 系统都会内建 vi 文书编辑器，其他的文书编辑器则不一定会存在。\n但是目前我们使用比较多的是 vim 编辑器。\nvim 具有程序编辑的能力，可以主动的以字体颜色辨别语法的正确性，方便程序设计。\n1.2什么是 vim？Vim 是从 vi 发展出来的一个文本编辑器。代码补全、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。\n简单的来说， vi 是老式的字处理器，不过功能已经很齐全了，但是还是有可以进步的地方。 vim 则可以说是程序开发者的一项很好用的工具。\n连 vim 的官方网站 (https://www.vim.org/) 自己也说 vim 是一个程序开发工具而不是文字处理软件。\n1.3 vi&#x2F;vim 的使用基本上 vi&#x2F;vim 共分为三种模式，命令模式（Command Mode）、输入模式（Insert Mode）和命令行模式（Command-Line Mode）。\n1.3.1 命令模式用户刚刚启动 vi&#x2F;vim，便进入了命令模式。\n此状态下敲击键盘动作会被 Vim 识别为命令，而非输入字符，比如我们此时按下 i，并不会输入一个字符，i 被当作了一个命令。\n以下是普通模式常用的几个命令：\n\ni – 切换到输入模式，在光标当前位置开始输入文本。\nx – 删除当前光标所在处的字符。\n: – 切换到底线命令模式，以在最底一行输入命令。\na – 进入插入模式，在光标下一个位置开始输入文本。\no：在当前行的下方插入一个新行，并进入插入模式。\nO – 在当前行的上方插入一个新行，并进入插入模式。\ndd – 剪切当前行。\nyy – 复制当前行。\np（小写） – 粘贴剪贴板内容到光标下方。\nP（大写）– 粘贴剪贴板内容到光标上方。\nu – 撤销上一次操作。\nCtrl + r – 重做上一次撤销的操作。\n:w – 保存文件。\n:q – 退出 Vim 编辑器。\n:q! – 强制退出Vim 编辑器，不保存修改。\n\n若想要编辑文本，只需要启动 Vim，进入了命令模式，按下 i 切换到输入模式即可。\n命令模式只有一些最基本的命令，因此仍要依靠底线命令行模式输入更多命令。\n1.3.2 输入模式在命令模式下按下 i 就进入了输入模式，使用 Esc 键可以返回到普通模式。\n在输入模式中，可以使用以下按键：\n\n字符按键以及Shift组合，输入字符\nENTER，回车键，换行\nBACK SPACE，退格键，删除光标前一个字符\nDEL，删除键，删除光标后一个字符\n方向键，在文本中移动光标\nHOME&#x2F;END，移动光标到行首&#x2F;行尾\nPage Up&#x2F;Page Down，上&#x2F;下翻页\nInsert，切换光标为输入&#x2F;替换模式，光标将变成竖线&#x2F;下划线\nESC，退出输入模式，切换到命令模式\n\n1.3.3 底线命令模式在命令模式下按下 **:**（英文冒号）就进入了底线命令模式。\n底线命令模式可以输入单个或多个字符的命令，可用的命令非常多。\n在底线命令模式中，基本的命令有（已经省略了冒号）：\n\n:w：保存文件。\n:q：退出 Vim 编辑器。\n:wq：保存文件并退出 Vim 编辑器。\n:q!：强制退出Vim编辑器，不保存修改。\n\n按 ESC 键可随时退出底线命令模式。\n简单的说，我们可以将这三个模式想成底下的图标来表示：\n\n\n1.4 vi&#x2F;vim 使用实例1.4.1 使用 vi&#x2F;vim 进入一般模式如果你想要使用 vi 来建立一个名为 runoob.txt 的文件时，你可以这样做：\n1$ vim runoob.txt\n\n直接输入 vi 文件名 就能够进入 vi 的一般模式了。请注意，记得 vi 后面一定要加文件名，不管该文件存在与否！\n\n1.4.2 按下 i 进入输入模式(也称为编辑模式)，开始编辑文字在一般模式之中，只要按下 i, o, a 等字符就可以进入输入模式了！\n在编辑模式当中，你可以发现在左下角状态栏中会出现 –INSERT- 的字样，那就是可以输入任意字符的提示。\n这个时候，键盘上除了 Esc 这个按键之外，其他的按键都可以视作为一般的输入按钮了，所以你可以进行任何的编辑。\n\n1.4.3 按下 ESC 按钮回到一般模式好了，假设我已经按照上面的样式给他编辑完毕了，那么应该要如何退出呢？是的！没错！就是给他按下 Esc 这个按钮即可！马上你就会发现画面左下角的 – INSERT – 不见了！\n1.4.4 在一般模式中按下 :wq 储存后离开 viOK，我们要存档了，存盘并离开的指令很简单，输入 :wq 即可保存离开！\n\nOK! 这样我们就成功创建了一个 runoob.txt 的文件。\n\n1.5 vi&#x2F;vim 按键说明除了上面简易范例的 i, Esc, :wq 之外，其实 vim 还有非常多的按键可以使用。\n1.5.1 第一部分：一般模式可用的光标移动、复制粘贴、搜索替换等\n\n\n移动光标的方法\n\n\n\n\nh 或 向左箭头键(←)\n光标向左移动一个字符\n\n\nj 或 向下箭头键(↓)\n光标向下移动一个字符\n\n\nk 或 向上箭头键(↑)\n光标向上移动一个字符\n\n\nl 或 向右箭头键(→)\n光标向右移动一个字符\n\n\n如果你将右手放在键盘上的话，你会发现 hjkl 是排列在一起的，因此可以使用这四个按钮来移动光标。 如果想要进行多次移动的话，例如向下移动 30 行，可以使用 “30j” 或 “30↓” 的组合按键， 亦即加上想要进行的次数(数字)后，按下动作即可！\n\n\n\n[Ctrl] + [f]\n屏幕『向下』移动一页，相当于 [Page Down]按键 (常用)\n\n\n[Ctrl] + [b]\n屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用)\n\n\n[Ctrl] + [d]\n屏幕『向下』移动半页\n\n\n[Ctrl] + [u]\n屏幕『向上』移动半页\n\n\n+\n光标移动到非空格符的下一行\n\n\n-\n光标移动到非空格符的上一行\n\n\nn\n那个 n 表示『数字』，例如 20 。按下数字后再按空格键，光标会向右移动这一行的 n 个字符。例如 20 则光标会向后面移动 20 个字符距离。\n\n\n0 或功能键[Home]\n这是数字『 0 』：移动到这一行的最前面字符处 (常用)\n\n\n$ 或功能键[End]\n移动到这一行的最后面字符处(常用)\n\n\nH\n光标移动到这个屏幕的最上方那一行的第一个字符\n\n\nM\n光标移动到这个屏幕的中央那一行的第一个字符\n\n\nL\n光标移动到这个屏幕的最下方那一行的第一个字符\n\n\nG\n移动到这个档案的最后一行(常用)\n\n\nnG\nn 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set nu)\n\n\ngg\n移动到这个档案的第一行，相当于 1G 啊！ (常用)\n\n\nn\nn 为数字。光标向下移动 n 行(常用)\n\n\n搜索替换\n\n\n\n&#x2F;word\n向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 &#x2F;vbird 即可！ (常用)\n\n\n?word\n向光标之上寻找一个字符串名称为 word 的字符串。\n\n\nn\n这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 &#x2F;vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！\n\n\nN\n这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。 例如 &#x2F;vbird 后，按下 N 则表示『向上』搜寻 vbird 。\n\n\n使用 &#x2F;word 配合 n 及 N 是非常有帮助的！可以让你重复的找到一些你搜寻的关键词！\n\n\n\n:n1,n2s&#x2F;word1&#x2F;word2&#x2F;g\nn1 与 n2 为数字。在第 n1 与 n2 行之间寻找 word1 这个字符串，并将该字符串取代为 word2 ！举例来说，在 100 到 200 行之间搜寻 vbird 并取代为 VBIRD 则： 『:100,200s&#x2F;vbird&#x2F;VBIRD&#x2F;g』。(常用)\n\n\n:1,$s&#x2F;word1&#x2F;word2&#x2F;g 或 :%s&#x2F;word1&#x2F;word2&#x2F;g\n从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！(常用)\n\n\n:1,$s&#x2F;word1&#x2F;word2&#x2F;gc 或 :%s&#x2F;word1&#x2F;word2&#x2F;gc\n从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！且在取代前显示提示字符给用户确认 (confirm) 是否需要取代！(常用)\n\n\n删除、复制与贴上\n\n\n\nx, X\n在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字符(相当于 [backspace] 亦即是退格键) (常用)\n\n\nnx\nn 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， 『10x』。\n\n\ndd\n剪切游标所在的那一整行(常用)，用 p&#x2F;P 可以粘贴。\n\n\nndd\nn 为数字。剪切光标所在的向下 n 行，例如 20dd 则是剪切 20 行(常用)，用 p&#x2F;P 可以粘贴。\n\n\nd1G\n删除光标所在到第一行的所有数据\n\n\ndG\n删除光标所在到最后一行的所有数据\n\n\nd$\n删除游标所在处，到该行的最后一个字符\n\n\nd0\n那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符\n\n\nyy\n复制游标所在的那一行(常用)\n\n\nnyy\nn 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行(常用)\n\n\ny1G\n复制游标所在行到第一行的所有数据\n\n\nyG\n复制游标所在行到最后一行的所有数据\n\n\ny0\n复制光标所在的那个字符到该行行首的所有数据\n\n\ny$\n复制光标所在的那个字符到该行行尾的所有数据\n\n\np, P\np 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！ 举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？ 那么原本的第 20 行会被推到变成 30 行。 (常用)\n\n\nJ\n将光标所在行与下一行的数据结合成同一行\n\n\nc\n重复删除多个数据，例如向下删除 10 行，[ 10cj ]\n\n\nu\n复原前一个动作。(常用)\n\n\n[Ctrl]+r\n重做上一个动作。(常用)\n\n\n这个 u 与 [Ctrl]+r 是很常用的指令！一个是复原，另一个则是重做一次～ 利用这两个功能按键，你的编辑，嘿嘿！很快乐的啦！\n\n\n\n.\n不要怀疑！这就是小数点！意思是重复前一个动作的意思。 如果你想要重复删除、重复贴上等等动作，按下小数点『.』就好了！ (常用)\n\n\n1.5.2 第二部分：一般模式切换到编辑模式的可用的按钮说明\n\n\n进入输入或取代的编辑模式\n\n\n\n\ni, I\n进入输入模式(Insert mode)： i 为『从目前光标所在处输入』， I 为『在目前所在行的第一个非空格符处开始输入』。 (常用)\n\n\na, A\n进入输入模式(Insert mode)： a 为『从目前光标所在的下一个字符处开始输入』， A 为『从光标所在行的最后一个字符处开始输入』。(常用)\n\n\no, O\n进入输入模式(Insert mode)： 这是英文字母 o 的大小写。o 为在目前光标所在的下一行处输入新的一行； O 为在目前光标所在的上一行处输入新的一行！(常用)\n\n\nr, R\n进入取代模式(Replace mode)： r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下 ESC 为止；(常用)\n\n\n上面这些按键中，在 vi 画面的左下角处会出现『–INSERT–』或『–REPLACE–』的字样。 由名称就知道该动作了吧！！特别注意的是，我们上面也提过了，你想要在档案里面输入字符时， 一定要在左下角处看到 INSERT 或 REPLACE 才能输入喔！\n\n\n\n[Esc]\n退出编辑模式，回到一般模式中(常用)\n\n\n1.5.3 第三部分：一般模式切换到指令行模式的可用的按钮说明\n\n\n指令行的储存、离开等指令\n\n\n\n\n:w\n将编辑的数据写入硬盘档案中(常用)\n\n\n:w!\n若文件属性为『只读』时，强制写入该档案。不过，到底能不能写入， 还是跟你对该档案的档案权限有关啊！\n\n\n:q\n离开 vi (常用)\n\n\n:q!\n若曾修改过档案，又不想储存，使用 ! 为强制离开不储存档案。\n\n\n注意一下啊，那个惊叹号 (!) 在 vi 当中，常常具有『强制』的意思～\n\n\n\n:wq\n储存后离开，若为 :wq! 则为强制储存后离开 (常用)\n\n\nZZ\n这是大写的 Z 喔！如果修改过，保存当前文件，然后退出！效果等同于(保存并退出)\n\n\nZQ\n不保存，强制退出。效果等同于 **:q!**。\n\n\n:w [filename]\n将编辑的数据储存成另一个档案（类似另存新档）\n\n\n:r [filename]\n在编辑的数据中，读入另一个档案的数据。亦即将 『filename』 这个档案内容加到游标所在行后面\n\n\n:n1,n2 w [filename]\n将 n1 到 n2 的内容储存成 filename 这个档案。\n\n\n:! command\n暂时离开 vi 到指令行模式下执行 command 的显示结果！例如 『:! ls &#x2F;home』即可在 vi 当中察看 &#x2F;home 底下以 ls 输出的档案信息！\n\n\nvim 环境的变更\n\n\n\n:set nu\n显示行号，设定之后，会在每一行的前缀显示该行的行号\n\n\n:set nonu\n与 set nu 相反，为取消行号！\n\n\n特别注意，在 vi&#x2F;vim 中，数字是很有意义的！数字通常代表重复做几次的意思！ 也有可能是代表去到第几个什么什么的意思。\n举例来说，要删除 50 行，则是用 『50dd』 对吧！ 数字加在动作之前，如我要向下移动 20 行呢？那就是『20j』或者是『20↓』即可。\n2.编译器：gcc和g++C程序的编译过程\n使用方法1234567891011121314151617gcc/g++ [选项] 源文件选项：    -E：让编译器在预处理之后停止，不进行后续编译过程，得到.i文件    -S：让编译器在编译之后停止 ，不进行后续过程，得到.s文件    -c：生成机器码即二进制.o文件    -o：指定目标文件名    -g：在编译的时候生成调试信息    -Wall：生成所有警告信息    -I 目录：指定头文件的查找目录    生成动态链接库：        1. gcc/g++ -c -fPIC 源文件 -o 目标文件名        2. gcc -shared 目标文件名 -o 动态链接库名.so    生成静态链接库：        1. gcc/g++ -c 源文件 -o 目标文件名        2. ar -crv 静态链接库名.a 目标文件名    -l库名 -L 目录：引入链接库，-L指定查找该库的目录。如-lm表示引入libm.so\n\n3.调试工具：gdb使用方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#第一步：得到可执行文件gcc/g++ -o 可执行文件 -g 源文件#第二步：启动gdbgdb #启动gdb#第三步：执行gdb命令进行调试(gdb) gdb命令gdb命令：    file 可执行文件：导入需要调试的文件    r：运行程序    q：退出gdb    b：设置断点        b 行号        b 函数名称        b *函数名        b *代码地址        b 编号    c：继续执行，直到下一断点或程序结束    s：执行一行代码，如果此行代码有函数调用则进入函数    n：执行一行代码，如果此行代码有函数调用，不进入函数，直接执行函数    i(info) 子命令：查看某些信息（只输入info或i可以查看有哪些子命令）        info thread：查看进程的所有线程，会显示每个线程的序号（1~n）    thread 线程序号：切换到相应的线程（线程序号可以由info thread得到）    f(frame) 函数栈帧号：切换到相应的函数栈帧（函数栈帧号可以由where等命令得到）    list：查看源码        list 行号：查看指定行号附近的源码        list 函数：查看指定函数附近的源码        list 文件:行号：查看指定文件中指定行附近的代码    where：查看当前位置    p(print) /格式 表达式        格式：            x：按十六进制格式显示变量            d：按十进制格式显示变量            u：按十六进制格式显示无符号整形            o：按八进制格式显示变量            t：按二进制格式显示变量            a：按十六进制格式显示变量            c：按字符格式显示变量            f：按浮点数格式显示变量        表达式中可用的操作符：            @：一个和数组有关的操作符，左边是起始地址，右边是长度（p *arr@3）            ::：指定一个在文件或是函数中的变量（p &#x27;f2.c&#x27;::x）            &#123;&lt;type&gt;&#125;&lt;addr&gt;：一个指向内存&lt;addr&gt;的类型为type的一个对象    x(examine) &lt;n/f/u&gt; &lt;addr&gt;：查看内存        n：正整数，表示需要显示的内存单元个数        f：显示的格式（格式字母同上面的print）        u：每个单元的字节数            b：1字节            h：2字节            w：4字节（默认）            g：8字节\n\n4.查看依赖库：ldd5.二进制文件分析：objdump6.ELF文件格式分析：readelf7.跟踪进程中系统调用：strace8.跟踪进程栈：pstack9.进程内存映射：pmap六.其他1.终止进程：kill2.修改文件权限：chmod\nw权限不具有删除文件的能力\n目录的x权限表示能否进入目录\n\n使用方法12345chmod [选项] [u|g|o|a][+|-][r|w|x] 文件或目录chmod [选项] 权限的数字表示 文件或目录选项：    -R：递归式的修改\n\n3.创建链接：ln4.显示文件尾：tail5.版本控制：git6.设置别名：alias","slug":"Linux常用命令","date":"2024-09-09T14:06:25.408Z","categories_index":"Linux","tags_index":"常用命令","author_index":"神秘奇男子"},{"id":"b7eae51efb7dc6d81a7837b0d6a16f52","title":"Git的简单归纳","content":"Git的简单归纳\n\n\n\n\n\n\n\n\n内容修改自github博主arkingc，持续修改补充中\n\n\n\n一.git配置\n1.配置git用户名和邮箱\n\n\n二.仓库\n1.创建git仓库\n2.查看仓库状态\n3.远程仓库\n4.协同工作\n5.使用GitHub\n\n\n三.版本控制\n1.添加或删除修改\n2.提交版本\n3.文件删除\n4.工作现场保存与恢复\n5.改动查询\n6.版本回退\n7.查看历史提交\n\n\n四.分支管理\n1.创建与合并分支\n2.分支合并冲突\n3.分支管理策略\n\n\n\n\n\n\n\n一.git配置优先级：--local &gt; --global &gt; --system\n\n\n\n\n\n\n\n\n\n用了--global这个参数，表示你这台机器上所有的Git仓库都会使用这个配置\n1.配置git用户名和邮箱1234git config --global user.name        # 查看git config --global user.name 用户名  # 修改git config --global user.email       # 查看git config --global user.email 邮箱   # 修改\n\n\n\n二.仓库1.创建git仓库12git init 仓库名  #创建一个git仓库git init        #将一个项目转化为使用git管理（创建.git目录）\n\n示例：\n\n目录结构：\n12345678910project   |------.git            |--------branches            |--------config        #仓库的配置文件            |--------description            |--------HEAD            |--------hooks            |--------info            |--------objects            |--------refs\n\n\n\n\n\n\n\n\n\n\n隐藏目录.git不算工作区，而是Git的版本库\n2.查看仓库状态1git status\n\n\n\n3.远程仓库\n\n\n\n\n\n\n\n\n最早，肯定只有一台机器有一个原始版本库，此后，别的机器可以“克隆”这个原始版本库，而且每台机器的版本库其实都是一样的，并没有主次之分\n实际情况往往是这样，找一台电脑充当服务器的角色，每天24小时开机，其他每个人都从这个“服务器”仓库克隆一份到自己的电脑上，并且各自把各自的提交推送到服务器仓库里，也从服务器仓库中拉取别人的提交\nGitHub就是提供Git仓库托管服务的，所以，只要注册一个GitHub账号，就可以免费获得Git远程仓库，即Github为我们的git仓库提供了一个远程仓库，有了这个远程仓库，妈妈再也不用担心我的硬盘了\n1）为本地与GitHub的通信配置ssh本地git仓库和GitHub上的远程仓库之间的传输是通过SSH加密的，所以，需要一点设置：\n\n创建ssh key： 1ssh-keygen -t rsa -C &quot;youremail@example.com&quot;\n登录你的GitHub帐号，Settings -&gt; SSH and GPG keys -&gt; new SSH key ，将id_rsa.pub的内容复制进去\n\n\n\n\n\n\n\n\n\n\n为什么GitHub需要SSH Key呢？因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送\n2）让本地git仓库和远程仓库同步\n\n\n\n\n\n\n\n\n在有了本地git仓库后，还需创建对应的远程仓库\n\n在GitHub上创建远程仓库（如果已有则省略）\n为本地仓库设置远程仓库信息（如果同时需要为本地仓库添加多个远程仓库（如果github+码云），则可以将origin分别换成github和gitee，推送操作时也要修改origin。添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库） 1git remote add origin https://github.com/用户名/仓库名\n\n删除本地仓库的远程仓库信息：git remote remove origin\n修改远端地址：git remote set-url 新地址\n查看远程仓库信息：git remote -v\n\n\n将本地git仓库push到远程仓库 1234# 由于远程库是空的，我们第一次推送master分支时，加上了-u参数,Git不但会把本地的# master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master# 分支关联起来，在以后的推送或者拉取时就可以简化命令git push [-u] origin 分支名\n\n并不是一定要把本地分支往远程推送。哪些分支需要推送、哪些不需要呢？\n\nmaster：主分支，要时刻与远程同步\ndev：开发分支，团队所有成员都需要在上面工作，所有也需要与远程同步\nbug：只用于在本地修复bug，就没必要推送到远程了，除非老板要看看你每周修复了几个bug\n\n4.协同工作拉取分支：\n1git pull\n\ngit clone时，默认情况下只能看到本地的master分支。如果要在dev分支上开发，就必须创建远程origin的dev分支到本地，可以使用如下命令创建本地dev分支：\n1git checkout -b dev\n\n将本地dev分支与远程origin/dev分支关联起来：\n1git branch --set-upstream dev origin/dev\n\n\n\n5.使用GitHubBootstrap的官方仓库twbs&#x2F;bootstrap、你在GitHub上克隆的仓库my&#x2F;bootstrap，以及你自己克隆到本地电脑的仓库，他们的关系就像下图显示的那样：\n\n如果你想修复bootstrap的一个bug，或者新增一个功能，立刻就可以开始干活，干完后，往自己的仓库推送\n如果你希望bootstrap的官方库能接受你的修改，你就可以在GitHub上发起一个pull request。当然，对方是否接受你的pull request就不一定了\n\n\n\n\n三.版本控制隐藏目录.git不算工作区，而是Git的版本库。版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区。还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD\n\n1.添加或删除修改将修改添加到暂存区：\n1git add 文件/目录\n\n从暂存区删除修改：\n1git rm --cached 文件/目录\n\n以下命令可以将暂存区的修改重置，暂存区的改变会被移除到工作区：\n1git reset HEAD [文件名]\n\n以下命令可以丢弃工作区的修改：\n1git checkout -- [文件名]\n\n如果刚对一个文件进行了编辑，可以撤销文件的改变，回到编辑开始。命令其实起到“一键恢复”的作用，还可用于“误删恢复”。可以在 git reset HEAD [文件名] 后使用\n2.提交版本如果修改了readme.txt，添加了文件LICENSE，并将2者添加到暂存区后，暂存区的状态就变成这样：\n\n使用commit提交修改，实际上就是把暂存区的所有内容提交到当前分支：\n1git commit -m &#x27;信息&#x27;\n\n\n\n\n\n\n\n\n\n\n\ncommit相当于游戏里面一次存档。对应一个版本\n3.文件删除rm做出的删除不会被暂存，git rm做出的改变会被暂存。如果使用rm删除掉，能使用git rm来暂存。git rm不在意文件已经不存在了\n\n删除(暂存)单个文件\n  1git rm\n\n删除(暂存)多个文件（一般情况下，更可能是对大量文件进行管理。可能同时会删除很多文件，不可能使用git rm一个个删除）\n  12# 它会变量当前目录，将所有删除暂存git add -u .\n\n如果有文件被误删，可以使用git checkout -- 文件名恢复\n4.工作现场保存与恢复有时候在修复bug或某项任务还未完成，但是需要紧急处理另外一个问题。此时可以先保存工作现场，当问题处理完成后，再恢复bug或任务的进度\n\n保存工作现场：git stash\n查看保存的工作现场：git stash list\n恢复工作现场：git stash apply\n删除stash内容：git stash drop\n恢复工作现场并删除stash内容（相当于上面2步合并）：git stash pop\n\n5.改动查询1234567git diff [选项]           # 查看工作区中的修改git diff [选项] --staged   # 查看已添加到暂存区的修改git diff [选项] HEAD       # 查看当前所有未提交的修改选项：    --color-words： 颜色    --stat：        不显示具体修改，只显示修改了的文件\n\n6.版本回退123456git reset --hard 版本ID/HEAD形式的版本git reset --hard HEAD      # 当前版本git reset --hard HEAD^     # 上一个版本git reset --hard HEAD^^    # 上上个版本git reset --hard HEAD~n    # 前n个版本\n\n如果回到过去的版本，想要回到原来新的版本：\n\n如果终端未关，可以找到新版本的id，通过上述命令回去新版本\n如果终端已关，git reflog查看版本，再通过上述命令回去新版本\n\n7.查看历史提交1234567git log [选项]选项：    --online：只显示提交提示信息    --stat：添加每次提交包含的文件信息    --path：查看每次提交改变的内容    --graph\n\n加文件名可以显示具体文件相关的所有提交信息\n\n\n四.分支管理1.创建与合并分支每次commit相当于一次存档，对应一个版本。Git都把它们串成一条时间线，这条时间线就是一个分支。master就是主分支。HEAD指向当前分支，而master指向主分支的最近提交。每次提交，master分支都会向前移动一步\n当创建一个分支时，如dev，Git创建一个指针dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上：\n  \n\n从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变：\n  \n\n假如我们在dev上的工作完成了，就可以把dev合并到master上。最简单的方法，就是直接把master指向dev的当前提交，就完成了合并：\n  \n\n合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支：\n  \n\n上面的合并使用的是Fast forward。这种模式下，删除分支后，会丢掉分支信息。如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的提交，这样，从分支历史上就可以看出分支信息。通过在git merge命令中使用--no-ff选项禁用Fast forward模式。比如在合并dev时：\n1git merge --no-ff -m &quot;merge with no-ff&quot; dev\n\n由于会生成一个新的提交，所以需要使用-m指明新提交的信息。此时分支情况如下：\n  \n\n相关命令如下：\n\n(创建分支并)切换到新分支：git checkout -b 新分支\n创建分支：git branch 新分支\n切换分支：git checkout 欲切换到的分支\n查看当前分支：git branch\n合并某分支到当前分支：git merge 欲合并到当前分支的分支\n查看历史分支情况：git log --graph --pretty=oneline --abbrev-commit\n删除未合并的分支：git branch -D 分支\n\n2.分支合并冲突如果两个分支修改了同一文件，合并时会发生冲突。比如master分支和feature1分支都修改了readme.txt文件，各自都有新的提交：\n  \n\n这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突。此时readme.txt文件会变成如下形式：\n123456789Git is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage.Git tracks changes of files.&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADCreating a new branch is quick &amp; simple.=======Creating a new branch is quick AND simple.&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1\n\nGit用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，此时需要手动修改后保存。然后再使用git commit进行一次提交。分支会变成如下：\n  \n\n3.分支管理策略在实际开发中，我们应该按照几个基本原则进行分支管理\n首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活\n干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本\n你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了\n所以，团队合作的分支看起来就像这样：\n  \n\n当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin\n要查看远程库的信息，用git remote：\n12$ git remoteorigin\n\n或者，用git remote -v显示更详细的信息：\n123$ git remote -vorigin  git@github.com:michaelliao/learngit.git (fetch)origin  git@github.com:michaelliao/learngit.git (push)\n\n上面显示了可以抓取和推送的origin的地址。如果没有推送权限，就看不到push的地址\n推送分支1git push origin 欲推送的分支\n\n\nmaster分支是主分支，因此要时刻与远程同步\ndev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步\nbug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug\nfeature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发\n\n","slug":"Git简介","date":"2024-09-09T13:29:06.476Z","categories_index":"Git","tags_index":"git简介,git简单使用","author_index":"神秘奇男子"},{"id":"3c9c3f4226248e23e6c72e4ac83d74c5","title":"简单的水果分类识别","content":"任务一：水果分类识别​\t首先我先描述一下我的大体实现思路：\n整体思路流程\n特征提取：从图像中提取两类特征（边界特征和纹理特征），用于描述水果的形状和表面纹理。\n\n数据处理：读取数据目录中的图像，提取特征并准备数据集。\n\n模型训练：使用提取的特征数据训练一个逻辑回归模型，并保存为一个模型文件以待调用。\n\n单个图像预测：使用训练好的模型对单个图像进行预测，并输出预测结果。\n\n\n\n\n\n\n\n\n\nWARNING\n其中边界特征利用Canny算法提取，然后在图像内部划分子区域进行纹理特征提取，最后特征向量都要归一化处理。\n\n1.1 特征提取之边界特征提取​\t通过搜寻相关资料，利用canny进行提取边缘的步骤如下(参考下方代码)：\n1.灰度转换：将输入的彩色图像转换为灰度图像。2.高斯模糊：对灰度图像进行高斯模糊处理以减少噪声。3.Canny 边缘检测：使用 Canny 算法提取图像的边缘。4.轮廓检测：找到图像中的所有轮廓。5.计算线段长度：遍历每个轮廓，计算任意两点之间的距离。\n6. 划分区间：划分十个区间统计各个区间线段数量\n7.归一化特征：对所有线段长度进行归一化处理。\n\n\n点击这里查看边界特征提取代码\n123456789101112131415161718192021222324252627282930# 边界特征提取函数def extract_shape_features(image):    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)    blurred = cv2.GaussianBlur(gray, (5, 5), 0)    edges = cv2.Canny(blurred, 50, 150)    contours, _ = cv2.findContours(edges, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)    all_distances = []    for contour in contours:        num_points = len(contour)        distances = []        for i in range(num_points):            for j in range(i + 1, num_points):                distance = cv2.norm(contour[i] - contour[j])                distances.append(distance)        all_distances.extend(distances)    all_distances = np.array(all_distances)    if all_distances.size == 0:        return np.zeros(10)    bins = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100]    histogram, _ = np.histogram(all_distances, bins=bins)    feature_vector = histogram / np.sum(histogram)    return feature_vector\n\n\n1.2 特征提取之纹理特征提取经查询相关资料，纹理特征提取步骤如下（参考下面代码）：\n\n灰度转换：将输入的彩色图像转换为灰度图像。\n分割图像：将图像分割成四个子区域。\n提取子区域特征：对每个子区域计算均值和标准差。\n归一化特征向量：将特征向量归一化。\n返回特征向量：返回最终的纹理特征向量。\n\n\n点击这里查看纹理特征提取代码\n123456789101112131415161718192021222324252627def extract_texture_features(image, num_regions=4):    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)    h, w = gray.shape    region_height = h // 2    region_width = w // 2    texture_features = []    regions = [        (0, 0, region_height, region_width),        (0, region_width, region_height, w),        (region_height, 0, h, region_width),        (region_height, region_width, h, w)    ]    for (y_start, x_start, y_end, x_end) in regions:        roi = gray[y_start:y_end, x_start:x_end]        mean = np.mean(roi)        std_dev = np.std(roi)        texture_features.extend([mean, std_dev])    texture_features = np.array(texture_features)    if np.linalg.norm(texture_features) &gt; 0:        texture_features = texture_features / np.linalg.norm(texture_features)    return texture_features\n\n\n2 数据处理​\t训练的数据集大部分来自百度飞桨的公开数据库，参考链接：https://aistudio.baidu.com/datasetdetail/90377，\n​\t还有部分来自谷歌图片上手动下载保存，为了确保特征提取准确、模型预测更精准，我删除了大量较复杂的图片，只保留了简单的、具有单个水果、特征明显的图片，因此最后的图片数量不多。\n​\t为了使数据多样化、尽可能避免过拟合现象，我搜寻了一些简单的数据增强的方法，基于现有的图片数据增生了一些图片。如下面图片既包括搜集到的数据，也包括增生的数据。\n\n准备完了数据，我们开始利用之前的方法提取特征：\n\n路径和标签初始化：初始化两个列表 image_paths 和 labels 用于存储图像路径和标签。\n标签映射：定义一个字典 label_map 将水果类型映射为整数标签。\n读取图像并提取特征：读取每张图像，提取形状特征和纹理特征，并将它们合并为一个特征向量。\n返回特征矩阵和标签数组：将特征列表转换为 NumPy 数组，并返回特征矩阵和标签数组。\n\n\n点击这里查看数据处理部分的代码\n123456789101112131415161718192021222324252627282930313233343536# 数据准备def prepare_data(base_dir):    image_paths = []    labels = []    label_map = &#123;&#x27;apple&#x27;: 0, &#x27;banana&#x27;: 1, &#x27;orange&#x27;: 2&#125;    for fruit_type, label in label_map.items():        fruit_dir = os.path.join(base_dir, fruit_type)        if os.path.isdir(fruit_dir):            for filename in os.listdir(fruit_dir):                if filename.lower().endswith((&#x27;.png&#x27;, &#x27;.jpg&#x27;, &#x27;.jpeg&#x27;)):                    image_paths.append(os.path.join(fruit_dir, filename))                    labels.append(label)    X = []    y = np.array(labels)    for path in image_paths:        image = cv2.imread(path)        if image is None:            print(f&quot;警告：无法读取图像 &#123;path&#125;，请检查文件路径。&quot;)            continue        shape_features = extract_shape_features(image)        texture_features = extract_texture_features(image)        features = np.hstack((shape_features, texture_features))        X.append(features)    return np.array(X), y# 使用 JPEGImages 目录进行数据准备base_dir = &#x27;JPEGImages&#x27;X, y = prepare_data(base_dir)# 归一化特征scaler = StandardScaler()X = scaler.fit_transform(X)\n\n\n\n3 模型训练模型训练大致分以下几步：\n\n数据划分：将数据划分为80%训练集和20%测试集，以确保模型在未知数据上的泛化能力。\n\n模型创建和训练：创建逻辑回归模型，并使用训练集进行训练。\n\n模型预测：使用训练好的模型对测试集进行预测，得到预测标签。\n\n模型评估：计算预测标签与真实标签之间的准确率、精度、召回率，评估模型性能。\n\n\n\n\n\n\n\n\n\n\n\n（经检验运行后发现模型效果非常理想，这和我删除了大量较复杂的图片，只保留了简单的、具有单个水果、特征明显的图片有较大关系）\n\n\n点击这里查看上述步骤的代码\n123456789101112131415161718192021222324# 划分训练集和测试集X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)# 创建逻辑回归模型并训练model = LogisticRegression(max_iter=1000)model.fit(X_train, y_train)# 保存模型和标准化器model_filename = &#x27;model.pkl&#x27;scaler_filename = &#x27;scaler.pkl&#x27;joblib.dump(model, model_filename)joblib.dump(scaler, scaler_filename)# 计算准确率y_pred = model.predict(X_test)accuracy = accuracy_score(y_test, y_pred)precision = precision_score(y_test, y_pred, average=&#x27;weighted&#x27;)recall = recall_score(y_test, y_pred, average=&#x27;weighted&#x27;)print(f&quot;模型准确率: &#123;accuracy:.2f&#125;&quot;)print(f&quot;模型精度: &#123;precision:.2f&#125;&quot;)print(f&quot;模型召回率: &#123;recall:.2f&#125;&quot;)\n\n\n\n4 单个图像预测最后我们可以利用之前训练好的模型进行图片预测,可以将其封装成一个函数，函数实现步骤如下：\n\n读取图像：使用 cv2.imread 读取待测试的图像。\n特征提取：提取图像的形状特征和纹理特征。\n合并特征：将形状特征和纹理特征合并为一个特征向量，并重塑为 (1, -1) 形状。\n特征缩放：使用预先训练好的 scaler 对特征进行缩放处理。\n模型预测：使用训练好的模型对缩放后的特征进行预测。\n\n\n点击这里查看预测示例\n123456789101112131415161718192021222324252627282930313233343536import cv2import numpy as npimport joblibfrom fruits.categorize import extract_shape_features, extract_texture_features# 加载模型和标准化器model_filename = &#x27;model.pkl&#x27;scaler_filename = &#x27;scaler.pkl&#x27;model = joblib.load(model_filename)scaler = joblib.load(scaler_filename)# 单个图像分类示例def predict_image(image_path):    image = cv2.imread(image_path)    if image is None:        print(f&quot;无法读取图像 &#123;image_path&#125;，请检查路径。&quot;)        return None    shape_features = extract_shape_features(image)    texture_features = extract_texture_features(image)    features = np.hstack((shape_features, texture_features)).reshape(1, -1)    features = scaler.transform(features)    prediction = model.predict(features)    return prediction[0]# 使用模型预测水果类型test_image_path = &#x27;JPEGImages/banana/banana1.jpg&#x27;  # 替换为测试水果图像路径predicted_label = predict_image(test_image_path)if predicted_label is not None:    label_map_inverse = &#123;0: &#x27;苹果&#x27;, 1: &#x27;香蕉&#x27;, 2: &#x27;橙子&#x27;&#125;    print(f&quot;这个水果应该是: &#123;label_map_inverse.get(predicted_label, &#x27;无法识别的水果&#x27;)&#125;&quot;)\n\n\n\n最后将要测试的图片的路径修改入代码之中，运行之后即可看到预测的结果，结果如下\n\n5 完结撒花\n","slug":"水果分类识别","date":"2024-09-06T13:41:30.558Z","categories_index":"机器学习","tags_index":"水果分类,计算机视觉,逻辑回归","author_index":"神秘奇男子"},{"id":"dc76bdb116b22b7d8e614c5e499a6c3f","title":"Haar 特征分类器实现人脸识别","content":"基于OpenCV 的 Haar 特征分类器实现人脸检测与显示在计算机视觉领域，人脸检测是非常基础而且常用的技术，最近刚好在学计算机视觉的相关知识，学到人脸识别时，感到比较有趣\n于是简单写一下我的实现过程。[](￣▽￣)*\n本文将展示如何使用 OpenCV 和 Python 来实现简单的人脸检测，并使用 Matplotlib 对结果进行可视化。\n1. 环境配置首先，我们需要确保已安装必要的库：\n1pip install opencv-python matplotlib\n\n2. 代码实现代码分为几个关键部分：图像的读取与处理、人脸检测、绘制矩形框以及结果显示。\n2.1. 导入所需的库我们首先导入 OpenCV 和 Matplotlib，用于图像处理和结果显示。\n12import cv2import matplotlib.pyplot as plt\n\n2.2. 定义显示图像的函数为了更好地展示图像，我定义了一个 show_img 函数，将 BGR 格式的图像转换为 RGB 格式，并用 Matplotlib 显示出来。\n123456def show_img(img, title, pos):    img_RGB = img[:, :, ::-1]  # BGR 转 RGB    plt.subplot(2, 2, pos)    plt.title(title)    plt.imshow(img_RGB)    plt.xticks([])  # 隐藏 x 轴刻度\n\n2.3. 绘制人脸矩形框的函数plot_rectangle 函数用于在人脸检测结果中绘制矩形框：\n1234def plot_rectangle(img, faces):    for (x, y, w, h) in faces:        cv2.rectangle(img, (x, y), (x + w, y + h), (0, 255, 255), 2)  # 绘制黄色矩形框    return img\n\n2.4. 主程序主程序中，我们加载图像、转换为灰度图，并使用 OpenCV 的 Haar 特征分类器进行人脸检测。最后，绘制检测到的人脸并显示图像。\n123456789101112def main():    image = cv2.imread(&quot;../resources/tg009.jpg&quot;)  # 读取图像    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)  # 转为灰度图    face_cascade = cv2.CascadeClassifier(&quot;haarcascade_frontalface_alt.xml&quot;)  # 加载分类器    faces = face_cascade.detectMultiScale(gray)  # 人脸检测    face_alt2 = plot_rectangle(image.copy(), faces)  # 绘制矩形框    plt.figure(figsize=(10, 10))    plt.suptitle(&quot;Face Detection&quot;, fontsize=14, fontweight=&quot;bold&quot;)    show_img(face_alt2, &quot;face_alt2&quot;, 1)    plt.show()\n\n\n\n\n\n\n\n\n\n\n\n\nWARNING\n上面代码值得注意的是,haarcascade_frontalface_alt2.xml分类器我是从opencv源码里面复制的，  还有其他几种分类器可以用:\n\n\n代码的运行效果如图所示：检测到的人脸区域被黄色矩形框标出，结果被显示在 Matplotlib 窗口中。\n\n3. 运行结果分析可以看到，最后效果并不是那么好，因为这个算法是比较老的了，现在利用深度学习的算法能做到非常精准，因此本方法了解一下就行。\n4. 结论本篇文章展示了如何使用 Python 和 OpenCV 实现人脸检测，以及如何利用 Matplotlib 对结果进行可视化。在实际项目中，人脸检测可以被应用于多种场景，如监控系统、智能门禁和人脸识别考勤等。\n","slug":"基于OpenCV 的 Haar 特征分类器实现人脸检测与显示","date":"2024-08-24T06:37:38.807Z","categories_index":"计算机视觉","tags_index":"OpenCV,人脸识别","author_index":"神秘奇男子"},{"id":"3ceded50fe0dd372bcf8c1a5f8350431","title":"Welcome to AUG's Blog","content":"\nHello,你们好！（づ￣3￣）づ╭❤️～欢迎来到我的博客我会不定期持续更新文章,欢迎大家批评指正","slug":"hello-world","date":"2024-08-21T13:16:45.064Z","categories_index":"","tags_index":"博客简介","author_index":"神秘奇男子"}]