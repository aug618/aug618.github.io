[{"id":"6567def797e3574f535ec70b74f4992c","title":"Linux常用命令-2","content":"Linux常用命令-2\n\n\n\n\n\n\n\n\n转载修改自黑马Linux学习笔记，持续修改补充中\nLinux的目录结构\n\n/，根目录是最顶级的目录了\nLinux只有一个顶级目录：/\n路径描述的层次关系同样适用/来表示\n&#x2F;home&#x2F;itheima&#x2F;a.txt，表示根目录下的home文件夹内有itheima文件夹，内有a.txt\n\nls命令功能：列出文件夹信息\n语法：ls [-l -h -a] [参数]\n\n参数：被查看的文件夹，不提供参数，表示查看当前工作目录\n-l，以列表形式查看\n-h，配合-l，以更加人性化的方式显示文件大小\n-a，显示隐藏文件\n\n隐藏文件、文件夹在Linux中以.开头的，均是隐藏的。\n默认不显示出来，需要-a选项才可查看到。\npwd命令功能：展示当前工作目录\n语法：pwd\ncd命令功能：切换工作目录\n语法：cd [目标目录]\n参数：目标目录，要切换去的地方，不提供默认切换到当前登录用户HOME目录\nHOME目录每一个用户在Linux系统中都有自己的专属工作目录，称之为HOME目录。\n\n普通用户的HOME目录，默认在：/home/用户名\n\nroot用户的HOME目录，在：/root\n\n\nFinalShell登陆终端后，默认的工作目录就是用户的HOME目录\n相对路径、绝对路径\n相对路径，&#x3D;&#x3D;非&#x3D;&#x3D;/开头的称之为相对路径\n相对路径表示以当前目录作为起点，去描述路径，如test/a.txt，表示当前工作目录内的test文件夹内的a.txt文件\n\n绝对路径，&#x3D;&#x3D;以&#x3D;&#x3D;/开头的称之为绝对路径\n绝对路径从根开始描述路径\n\n\n特殊路径符\n.，表示当前，比如.&#x2F;a.txt，表示当前文件夹内的a.txt文件\n..，表示上级目录，比如../表示上级目录，../../表示上级的上级目录\n~，表示用户的HOME目录，比如cd ~，即可切回用户HOME目录\n\nmkdir命令功能：创建文件夹\n语法：mkdir [-p] 参数\n\n参数：被创建文件夹的路径\n选项：-p，可选，表示创建前置路径\n\ntouch命令功能：创建文件\n语法：touch 参数\n\n参数：被创建的文件路径\n\ncat命令功能：查看文件内容\n语法：cat 参数\n\n参数：被查看的文件路径\n\nmore命令功能：查看文件，可以支持翻页查看\n语法：more 参数\n\n参数：被查看的文件路径\n在查看过程中：\n空格键翻页\nq退出查看\n\n\n\ncp命令功能：复制文件、文件夹\n语法：cp [-r] 参数1 参数2\n\n参数1，被复制的\n参数2，要复制去的地方\n选项：-r，可选，复制文件夹使用\n\n示例：\n\ncp a.txt b.txt，复制当前目录下a.txt为b.txt\ncp a.txt test&#x2F;，复制当前目录a.txt到test文件夹内\ncp -r test test2，复制文件夹test到当前文件夹内为test2存在\n\nmv命令功能：移动文件、文件夹\n语法：mv 参数1 参数2\n\n参数1：被移动的\n参数2：要移动去的地方，参数2如果不存在，则会进行改名\n\nrm命令功能：删除文件、文件夹\n语法：rm [-r -f] 参数...参数\n\n参数：支持多个，每一个表示被删除的，空格进行分隔\n选项：-r，删除文件夹使用\n选项：-f，强制删除，不会给出确认提示，一般root用户会用到\n\n\n\n\n\n\n\n\n\n\nrm命令很危险，一定要注意，特别是切换到root用户的时候。\nwhich命令功能：查看命令的程序本体文件路径\n语法：which 参数\n\n参数：被查看的命令\n\nfind命令功能：搜索文件\n语法1按文件名搜索：find 路径 -name 参数\n\n路径，搜索的起始路径\n参数，搜索的关键字，支持通配符*， 比如：*test表示搜索任意以test结尾的文件\n\ngrep命令功能：过滤关键字\n语法：grep [-n] 关键字 文件路径\n\n选项-n，可选，表示在结果中显示匹配的行的行号。\n参数，关键字，必填，表示过滤的关键字，带有空格或其它特殊符号，建议使用””将关键字包围起来\n参数，文件路径，必填，表示要过滤内容的文件路径，可作为内容输入端口\n\n\n\n\n\n\n\n\n\n\n参数文件路径，可以作为管道符的输入\nwc命令功能：统计\n语法：wc [-c -m -l -w] 文件路径\n\n选项，-c，统计bytes数量\n选项，-m，统计字符数量\n选项，-l，统计行数\n选项，-w，统计单词数量\n参数，文件路径，被统计的文件，可作为内容输入端口\n\n\n\n\n\n\n\n\n\n\n参数文件路径，可作为管道符的输入\n管道符|写法：|\n功能：将符号左边的结果，作为符号右边的输入\n示例：\ncat a.txt | grep itheima，将cat a.txt的结果，作为grep命令的输入，用来过滤itheima关键字\n可以支持嵌套：\ncat a.txt | grep itheima | grep itcast\necho命令功能：输出内容\n语法：echo 参数\n\n参数：被输出的内容\n\n&#96;反引号功能：被两个反引号包围的内容，会作为命令执行\n示例：\n\necho `pwd`，会输出当前工作目录\n\ntail命令功能：查看文件尾部内容\n语法：tail [-f] 参数\n\n参数：被查看的文件\n选项：-f，持续跟踪文件修改\n\nhead命令功能：查看文件头部内容\n语法：head [-n] 参数\n\n参数：被查看的文件\n选项：-n，查看的行数\n\n重定向符功能：将符号左边的结果，输出到右边指定的文件中去\n\n&gt;，表示覆盖输出\n&gt;&gt;，表示追加输出\n\nvi编辑器命令模式快捷键\n\n\n底线命令快捷键\n命令的选项我们学习的一系列Linux命令，它们所拥有的选项都是非常多的。\n比如，简单的ls命令就有：-a -A -b -c -C -d -D -f -F -g -G -h -H -i -I -k -l -L -m -n -N -o -p -q -Q -r-R -s -S -t -T -u -U -v -w -x -X -1等选项，可以发现选项是极其多的。\n课程中， 并不会将全部的选项都进行讲解，否则，一个ls命令就可能讲解2小时之久。\n课程中，会对常见的选项进行讲解， 足够满足绝大多数的学习、工作场景。\n查看命令的帮助可以通过：命令 --help查看命令的帮助手册\n\n查看命令的详细手册可以通过：man 命令查看某命令的详细手册\n\nLinux常用操作软件安装\nCentOS系统使用：\nyum [install remove search] [-y] 软件名称\ninstall 安装\nremove 卸载\nsearch 搜索\n-y，自动确认\n\n\n\n\nUbuntu系统使用\napt [install remove search] [-y] 软件名称\ninstall 安装\nremove 卸载\nsearch 搜索\n-y，自动确认\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nyum 和 apt 均需要root权限\nsystemctl功能：控制系统服务的启动关闭等\n语法：systemctl start | stop | restart | disable | enable | status 服务名\n\nstart，启动\nstop，停止\nstatus，查看状态\ndisable，关闭开机自启\nenable，开启开机自启\nrestart，重启\n\n软链接功能：创建文件、文件夹软链接（快捷方式）\n语法：ln -s 参数1 参数2\n\n参数1：被链接的\n参数2：要链接去的地方（快捷方式的名称和存放位置）\n\n日期语法：date [-d] [+格式化字符串]\n\n-d 按照给定的字符串显示日期，一般用于日期计算\n\n格式化字符串：通过特定的字符串标记，来控制显示的日期格式\n\n%Y   年%y   年份后两位数字 (00..99)\n%m   月份 (01..12)\n%d   日 (01..31)\n%H   小时 (00..23)\n%M   分钟 (00..59)\n%S   秒 (00..60)\n%s   自 1970-01-01 00:00:00 UTC 到现在的秒数\n\n\n\n示例：\n\n按照2022-01-01的格式显示日期\n\n\n按照2022-01-01 10:00:00的格式显示日期\n\n\n-d选项日期计算\n\n\n支持的时间标记为：\n\n\n\n\n\n时区修改时区为中国时区\n\nntp功能：同步时间\n安装：yum install -y ntp\n启动管理：systemctl start | stop | restart | status | disable | enable ntpd\n手动校准时间：ntpdate -u ntp.aliyun.com\nip地址格式：a.b.c.d\n\nabcd为0~255的数字\n\n特殊IP：\n\n127.0.0.1，表示本机\n0.0.0.0\n可以表示本机\n也可以表示任意IP（看使用场景）\n\n\n\n查看ip：ifconfig\n主机名功能：Linux系统的名称\n查看：hostname\n设置：hostnamectl set-hostname 主机名\n配置VMware固定IP\n修改VMware网络，参阅PPT，图太多\n\n设置Linux内部固定IP\n修改文件：/etc/sysconfig/network-scripts/ifcfg-ens33\n示例文件内容：\n12345678910111213141516171819TYPE=&quot;Ethernet&quot;PROXY_METHOD=&quot;none&quot;BROWSER_ONLY=&quot;no&quot;BOOTPROTO=&quot;static&quot;\t\t\t# 改为static，固定IPDEFROUTE=&quot;yes&quot;IPV4_FAILURE_FATAL=&quot;no&quot;IPV6INIT=&quot;yes&quot;IPV6_AUTOCONF=&quot;yes&quot;IPV6_DEFROUTE=&quot;yes&quot;IPV6_FAILURE_FATAL=&quot;no&quot;IPV6_ADDR_GEN_MODE=&quot;stable-privacy&quot;NAME=&quot;ens33&quot;UUID=&quot;1b0011cb-0d2e-4eaa-8a11-af7d50ebc876&quot;DEVICE=&quot;ens33&quot;ONBOOT=&quot;yes&quot;IPADDR=&quot;192.168.88.131&quot;\t\t# IP地址，自己设置，要匹配网络范围NETMASK=&quot;255.255.255.0&quot;\t\t# 子网掩码，固定写法255.255.255.0GATEWAY=&quot;192.168.88.2&quot;\t\t# 网关，要和VMware中配置的一致DNS1=&quot;192.168.88.2&quot;\t\t\t# DNS1服务器，和网关一致即可\n\nps命令功能：查看进程信息\n语法：ps -ef，查看全部进程信息，可以搭配grep做过滤：ps -ef | grep xxx\nkill命令\nnmap命令\nnetstat命令功能：查看端口占用\n用法：netstat -anp | grep xxx\nping命令测试网络是否联通\n语法：ping [-c num] 参数\n\nwget命令\ncurl命令\n\ntop命令功能：查看主机运行状态\n语法：top，查看基础信息\n可用选项：\n\n交互式模式中，可用快捷键：\n\ndf命令查看磁盘占用\n\niostat命令查看CPU、磁盘的相关信息\n\n\nsar命令查看网络统计\n\n环境变量\n临时设置：export 变量名&#x3D;变量值\n永久设置：\n针对用户，设置用户HOME目录内：.bashrc文件\n针对全局，设置/etc/profile\n\n\n\nPATH变量记录了执行程序的搜索路径\n可以将自定义路径加入PATH内，实现自定义命令在任意地方均可执行的效果\n$符号可以取出指定的环境变量的值\n语法：$变量名\n示例：\necho $PATH，输出PATH环境变量的值\necho $&#123;PATH&#125;ABC，输出PATH环境变量的值以及ABC\n如果变量名和其它内容混淆在一起，可以使用${}\n压缩解压压缩tar -zcvf 压缩包 被压缩1...被压缩2...被压缩N\n\n-z表示使用gzip，可以不写\n\nzip [-r] 参数1 参数2 参数N\n\n解压tar -zxvf 被解压的文件 -C 要解压去的地方\n\n-z表示使用gzip，可以省略\n-C，可以省略，指定要解压去的地方，不写解压到当前目录\n\nunzip [-d] 参数\n\nsu命令切换用户\n语法：su [-] [用户]\n\nsudo命令\n比如：\n1itheima ALL=(ALL)       NOPASSWD: ALL\n\n在visudo内配置如上内容，可以让itheima用户，无需密码直接使用sudo\nchmod命令修改文件、文件夹权限\n语法：chmod [-R] 权限 参数\n\n权限，要设置的权限，比如755，表示：rwxr-xr-x\n\n\n参数，被修改的文件、文件夹\n\n选项-R，设置文件夹和其内部全部内容一样生效\n\n\nchown命令修改文件、文件夹所属用户、组\n语法：chown [-R] [用户][:][用户组] 文件或文件夹\n\n用户组管理\n用户管理\ngenenv命令\ngetenv group，查看系统全部的用户组\n\n\ngetenv passwd，查看系统全部的用户\n\n\n\nenv命令查看系统全部的环境变量\n语法：env\n","slug":"Linux课程笔记","date":"2024-09-09T14:32:36.513Z","categories_index":"Linux","tags_index":"常用操作","author_index":"神秘奇男子"},{"id":"c25ac72fe97fa8d9f8252ec05550a8eb","title":"Linux常用命令-1","content":"Linux常用命令-1\n\n\n\n\n\n\n\n\n内容修改自github博主arkingc，持续修改补充中\n\n\n\n一.文件管理\n1.文件查找：find\n2.文件拷贝：cp\n3.打包解包：tar\n\n\n二.文本处理\n1.(显示行号)查看文件：nl\n2.文本查找：grep\n3.排序：sort\n4.转换：tr\n5.切分文本：cut\n6.拼接文本：paste\n7.统计：wc\n8.数据处理：sed\n9.数据处理：awk\n\n\n三.性能分析\n1.进程查询：ps\n2.进程监控：top\n3.打开文件查询：lsof\n4.内存使用量：free\n5.shell进程的资源限制：ulimit\n\n\n四.网络工具\n1.网卡配置：ifconfig\n2.查看当前网络连接：netstat\n3.查看路由表：route\n4.检查网络连通性：ping\n5.转发路径：traceroute\n6.网络Debug分析：nc\n7.命令行抓包：tcpdump\n8.域名解析工具：dig\n9.网络请求：curl\n\n\n五.开发及调试\n1.编辑器：vim\n2.编译器：gcc和g++\n3.调试工具：gdb\n4.查看依赖库：ldd\n5.二进制文件分析：objdump\n6.ELF文件格式分析：readelf\n7.跟踪进程中系统调用：strace\n8.跟踪进程栈：pstack\n9.进程内存映射：pmap\n\n\n六.其他\n1.终止进程：kill\n2.修改文件权限：chmod\n3.创建链接：ln\n4.显示文件尾：tail\n5.版本控制：git\n6.设置别名：alias  \n\n\n\n\n\n一.文件管理1.文件查找：find使用方法123456789101112131415find [查找目录] [查找条件]查找目录：    .：在当前目录及子目录下查找（默认）    A：在目录A及A的子目录下查找查找条件：    -name：根据文件名查找    -regex：使用正则表达式匹配    -type：按类型查找（f:文件，d:目录，l:链接...）    -atime：按访问时间查找（n:n天前的一天内，+n:n天前(不含n天本身)，-n:n天内(不含n天)）    -mtime：按修改时间查找（n:n天前的一天内，+n:n天前(不含n天本身)，-n:n天内(不含n天)）    -size：按大小查找（单位k，+nk:&quot;比nk更大&quot;，-nk:&quot;比nk更小&quot;）    -perm：按权限查找（644：权限等于644的文件）    -user/-nouser：用户名等于/用户名不等于    -group/-nogroup：组名等于/组名不等于\n\n示例12345#1.在当前目录及子目录下查找后缀为cpp的文件find . -name *.cpp#2.使用正则表达式查找find -regex &quot;.*.cpp$&quot;\n\n\n\n\n\n2.文件拷贝：cp使用方法123456cp [选项] 源路径 目的路径选项：    -a：将所有属性一起复制（包括拥有者、时间等信息）    -i：目标文件存在时，进行询问    -r：递归复制\n\n3.打包解包：tar使用方法1234567tar [-j|-z] [cv] [-f 压缩包名] 目录tar [-j|-z] [xv] [-f 解压包名] [-C 解压路径]选项：    -c/-x：打包/解包    -j/-z：bzip2格式/gzip格式    -v：显示过程\n\n二.文本处理1.(显示行号)查看文件：nl行号计算不包括空行\n2.文本查找：grep使用方法12345678grep [选项] 模式串 文件输出 | grep [选项] 模式串选项    -e：使用多个模式串    -i：忽略大小写    -n：打印行号    -c：统计次数（一行算一次）\n\n示例12#1.在test.c中搜索包含字符串”printf“或”count“的行grep -e &quot;printf&quot; -e &quot;count&quot; test.c\n\n3.排序：sort使用方法12345678sort [选项] 文件输出 | sort [选项]选项    -d：按字典序排序（默认）    -n：按数字排序    -k：&quot;-k n&quot;表示按各行第n列进行排序    -r：反序\n\n4.转换：tr使用方法123456#set1、set2为字符集，可以是单个字符，也可以是字符串输出 | tr [选项] set1 set2选项：    -d：删除字符    -s：字符压缩\n\n示例1234567891011#1.删除字符&#x27;:&#x27;cat /etc/passwd | tr -d &#x27;:&#x27;#2.将小写字母替换成大写字母last | tr &#x27;[a-z]&#x27; &#x27;A-Z&#x27;#3.将&#x27;a&#x27;、&#x27;b&#x27;、&#x27;c&#x27;替换成&#x27;z&#x27;cat test | tr “abc” &#x27;z&#x27;#4.将连续的&#x27;a&#x27;压缩成&#x27;b&#x27;（单个或连续出现的多个‘a’会压缩成一个‘b’）cat test | tr -s &#x27;a&#x27; &#x27;b&#x27;\n\n5.切分文本：cut使用方法1234567cut [选项] 文件输出 | cut [选项]选项：    -d：分隔符（-d &#x27;:&#x27; 以’:‘为分隔符）    -f：选择域（-f 1,2 输出分隔后第1列和第2列）    -c：字符范围（-c n-m 输出第n到m个字符。如果没有m，输出到末尾）\n\n示例12345#1.按’:‘分隔$PATH，输出第3个和第5个echo $PATH | cut -d &#x27;:&#x27; -f 3,5#2.输出export运行结果每行的第12-20个字符export | cut -c 12-20\n\n6.拼接文本：paste使用方法1234paste [选项] file1 file2选项：    -d：指定拼接时使用的分隔符（默认使用tab作为分隔符）\n\n7.统计：wc使用方法1234567wc [选项] 文件输出 | wc [选项]选项：    -c：统计字符数    -w：统计单词数    -l：统计行数\n\n8.数据处理：sed\n\n\n\n\n\n\n\n\nsed常用于一整行的处理。如果有一个100万行的文件，要在第100行加某些文字，此时由于文件太大，不适合用vim处理。因此使用sed是个很好的选择\n使用方法123456789101112131415sed [选项] &#x27;[动作]&#x27; 文件输入 | sed [选项] &#x27;[动作]&#x27;选项：    -n：安静模式，只输出sed处理过的行（否则未处理行也会输出）    -i：结果直接作用到文件（没指定时不会修改文件）    -e：在命令行模式上输入动作    -f：从文件中读取动作动作：[n1[,n2]] functionfunction:    a/i：在后插入/在前插入    d：删除    p：打印    s：替换\n\n示例123456789101112131415#1.插入nl /etc/passwd | sed &#x27;2a drink tea&#x27; #在第2行后插入一行：&quot;drink tea&quot;nl /etc/passwd | sed &#x27;2a aaa \\&gt; bbb&#x27; #在第2行后插入两行：&quot;aaa&quot;和&quot;bbb&quot;#2.删除nl /etc/passwd | sed &#x27;2,5d&#x27; #删除2~5行sed &#x27;/^$/d&#x27; ip #将ip文件中的空行删除#3.打印2~5行（安静模式，不使用安静模式2~5行会打印2次）nl /etc/passwd | sed -n &#x27;2,5p&#x27;#4.替换nl /etc/passwd | sed &#x27;2s/daemon/root/g&#x27; #将第二行的daemon替换成rootifconfig | grep &#x27;inet addr&#x27; | sed &#x27;s/^.*addr://g&#x27; #将所有开头的“inet addr:”删除\n\n9.数据处理：awk\n\n\n\n\n\n\n\n\n相比于sed常用于一整行的处理，awk则比较倾向于将一行分成数个“字段”来处理。因此，相当适合小型的数据处理\nawk处理步骤：\n\n读入第一行，并将第一行的数据填入$0,$1,$2等变量当中\n依据条件类型的限制，判断是否需要进行后面的动作\n做完所有的动作与条件类型\n若还有后续的“行”的数据，则重复1~3步，直到所有的数据都读完为止\n\n使用方法12345678910111213awk &#x27;条件类型1&#123;动作1&#125; 条件类型2&#123;动作2&#125; ...&#x27; filename输出 | awk &#x27;条件类型1&#123;动作1&#125; 条件类型2&#123;动作2&#125; ...&#x27;变量：    $0：整行    $1：按分隔符分隔后的第1列    $2：按分隔符分隔后的第2列    $k：按分隔符分隔后的第k列    NF：每一行拥有的字段数    NR：目前所处理的行数    FS：目前的分隔字符（默认是空格或tab）条件判断：&gt;、&lt;、&gt;=、&lt;=、==、!=命令分隔：使用&#x27;;&#x27;或Enter\n\n示例123456789#1.打印last -n 5结果中每行经过分隔符(默认情况下为空格或tab)分隔后的第1列和第3列last -n 5 | awk &#x27;&#123;print $1 &quot;\\t&quot; $3&#125;&#x27;#2.以&#x27;:&#x27;作为分隔符，打印第3列小于10的所有行的第1列和第3列cat /etc/passwd | awk &#x27;&#123;FS=&quot;:&quot;&#125; $3&lt;10&#123;print $1 &quot;\\t&quot; $3&#125;&#x27;      #（第一行不会处理）cat /etc/passwd | awk &#x27;BEGIN&#123;FS=&quot;:&quot;&#125; $3&lt;10&#123;print $1 &quot;\\t&quot; $3&#125;&#x27; #（第一行会处理）#3.假设test文件由3列数字组成，以空格分隔。该命令会计算每行的和然后打印awk &#x27;&#123;total=$1+$2+$3;printf &quot;%10d %10d %10d %10.2f\\n&quot;,$1,$2,$3,total&#125;&#x27; test\n\n注意上面的示例2，awk首先是读取一行，分隔后的数据填入$0,$1,$2等变量中才开始进行条件判断和执行动作。因此第一条命令在按空格或tab分隔后才将分隔符换成’:’，所以第一行显示结果不对\n三.性能分析1.进程查询：psman ps手册非常庞大，不是很好查阅，因此主要记住几个命令\n示例12345678#1.列出仅与自身环境有关的进程，最上层的父进程是允许该ps命令的bash而没有扩展到init进程中去ps -l#2.列出系统所有进程的信息ps auxps -ef    #aux会截断COMMAND列，-ef不会。aux是BSD风格，-ef是System V风格ps axjf   #以&quot;进程树&quot;的方式显示所有进程ps -lA    #输出格式同ps -l\n\n\n\nF：进程标志，说明进程的权限\n4：root权限\n1：仅能fork而不能exec\n0：既非4也非1\n\n\nS：进程的状态\nR(running)：正在运行\nS(Sleep)：可被唤醒的睡眠\nD：不可被唤醒的睡眠（通常可能在等待I&#x2F;O）\nT：停止，可能是在后台暂停\nZ(Zombie)：僵尸进程\n\n\nC：CPU使用率\nPRI&#x2F;NI：Priority&#x2F;Nice的缩写，CPU优先级(越小越高)\nADDR&#x2F;SZ&#x2F;WCHAN：内存相关，ADDR指出进程在内存的哪个部分，running进程一般显示’-‘。SZ为进程使用的内存。WCHAN表示进程当前是否运行中’-‘，当进程睡眠时，指出进程等待的事件\nTTY：进程运行的终端机\nTIME：进程用掉的CPU时间\n\n\n\nUSER：进程所属用户\n%CPU&#x2F;%MEM：进程消耗的CPU百分比和内存百分比\nVSZ：进程用掉的虚拟内存(KB)\nRSS：进程占用的固定内存(KB)\nTTY：进程运行的终端机，与终端机无关则显示’?’。tty1~tty6是本机的登陆者程序，pts&#x2F;0等表示由网络连接进主机的进程\nSTAT：进程目前的状态，与ps -l结果中的S等同\nSTART：进程启动的时间\nTIME：进程实际使用的CPU运行时间\n\n2.进程监控：top使用方法123456top [选项]选项：    -d：跟秒数指定更新间隔    -n：与-b搭配，指定需要进行几次top输出，重定向时常用    -p：指定PID，监控特定进程\n\ntop模式下的命令：\n\n**?**：显示可用的命令\nP：以CPU使用情况排序\nM：以内存使用情况排序\nN：以PID排序\nq：退出\n1：多核情况下切换CPU\n\n%Cpu(s)后面的“wa”表示I&#x2F;O wait，过高说明长时间等待I&#x2F;O，I&#x2F;O存在瓶颈\n3.打开文件查询：lsof使用方法1234567lsof [选项]选项：    -i：-i:端口号查看端口被占用的情况    -u：后跟用户名查看具体用户打开的文件    -p：后跟PID查看指定进程打开的文件    +d：后跟目录查看指定目录下被进程打开的文件，&quot;+D&quot;递归\n\n4.内存使用量：free使用方法12345free [选项]选项：    -b|-k|-m|-g：单位    -t：列出物理内存与swap的汇总情况    \n\n\n\nbuffers：主要缓存dentry和inode等元数据\ncached：主要缓存文件内容，即page cache\n- buffers&#x2F;cache：实际使用的内存。used-buffers-cached\n+ buffers&#x2F;cache：可用内存。free+buffers+cached（在内存紧张时，buffers和cached可以回收）\n\n详细结果说明\n5.shell进程的资源限制：ulimit使用方法123456ulimit [选项]       #查看ulimit [选项] 新值  #修改选项：    -a：列出shell进程的所有资源限制情况（-a命令会列出查看某一资源限制的选项参数）    ...\n\n使用ulimit修改资源限制只会对当前终端环境有效，如果想永久生效，可以修改文件/etc/security/limits.conf，该文件的内容如下；\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556# /etc/security/limits.conf##Each line describes a limit for a user in the form:##&lt;domain&gt;        &lt;type&gt;  &lt;item&gt;  &lt;value&gt;##Where:#&lt;domain&gt; can be:#        - a user name#        - a group name, with @group syntax#        - the wildcard *, for default entry#        - the wildcard %, can be also used with %group syntax,#                 for maxlogin limit#        - NOTE: group and wildcard limits are not applied to root.#          To apply a limit to the root user, &lt;domain&gt; must be#          the literal username root.##&lt;type&gt; can have the two values:#        - &quot;soft&quot; for enforcing the soft limits#        - &quot;hard&quot; for enforcing hard limits##&lt;item&gt; can be one of the following:#        - core - limits the core file size (KB)#        - data - max data size (KB)#        - fsize - maximum filesize (KB)#        - memlock - max locked-in-memory address space (KB)#        - nofile - max number of open files#        - rss - max resident set size (KB)#        - stack - max stack size (KB)#        - cpu - max CPU time (MIN)#        - nproc - max number of processes#        - as - address space limit (KB)#        - maxlogins - max number of logins for this user#        - maxsyslogins - max number of logins on the system#        - priority - the priority to run user process with#        - locks - max number of file locks the user can hold#        - sigpending - max number of pending signals#        - msgqueue - max memory used by POSIX message queues (bytes)#        - nice - max nice priority allowed to raise to values: [-20, 19]#        - rtprio - max realtime priority#        - chroot - change root to directory (Debian-specific)##&lt;domain&gt;      &lt;type&gt;  &lt;item&gt;         &lt;value&gt;##*               soft    core            0#root            hard    core            100000#*               hard    rss             10000#@student        hard    nproc           20#@faculty        soft    nproc           20#@faculty        hard    nproc           50#ftp             hard    nproc           0#ftp             -       chroot          /ftp#@student        -       maxlogins       4# End of file\n\n示例1234567891011121314151617root@068ca8da6d06:/# ulimit -acore file size          (blocks, -c) 0data seg size           (kbytes, -d) unlimitedscheduling priority             (-e) 0file size               (blocks, -f) unlimitedpending signals                 (-i) 7863max locked memory       (kbytes, -l) 82000max memory size         (kbytes, -m) unlimitedopen files                      (-n) 1048576pipe size            (512 bytes, -p) 8POSIX message queues     (bytes, -q) 819200real-time priority              (-r) 0stack size              (kbytes, -s) 8192cpu time               (seconds, -t) unlimitedmax user processes              (-u) unlimitedvirtual memory          (kbytes, -v) unlimitedfile locks                      (-x) unlimited\n\n四.网络工具1.网卡配置：ifconfig2.查看当前网络连接：netstat1234567891011netstat [选项]选项：    -a：将所有的连接、监听、Socket数据都列出来（如，默认情况下，不会列出监听状态的连接）    -t：列出tcp连接    -u：列出udp连接    -n：将连接的进程服务名称以端口号显示（如下图中Local Address会换成10.0.2.15:22）    -l：列出处于监听状态的连接    -p：添加一列，显示网络服务进程的PID（需要root权限）    -i：显示网络接口列表，可以配合ifconfig一起分析    -s：打印网络统计数据，包括某个协议下的收发包数量\n\n\n\nActive Internet connections（w&#x2F;o servers）：网络相关的连接\nRecv-Q：接收队列(已接收还未递交给应用)\nSend-Q：发送队列(接收方未确认的数据)\nLocal Address：本地IP(主机):端口(服务名)\nForeign Address：远端IP:端口\n\n\n\n\n\n\n\n\n\nRecv-Q和Send-Q通常应该为0，如果长时间不为0可能存在问题\n\n\n\nActive UNIX domain sockets（w&#x2F;o servers）：本地相关的套接字\nRefCnt：连接到此socket的进程数\nFlags：连接标识\nType：socket访问的类型\nPath：连接到此socket的相关程序的路径\n\n\n\nnetstat的10个基本用法\n3.查看路由表：route4.检查网络连通性：ping5.转发路径：traceroute6.网络Debug分析：nc7.命令行抓包：tcpdump使用方法1234sudo tcpdump [选项] ...选项：    -D/-i：查看/指定网卡\n\n示例12#抓取本地9877号端口的TCP数据包sudo tcpdump -i lo tcp port 9877\n\n下图为tcp回射服务器，客户端分别键入”hello”和“world”时，使用tcpdump抓取到的数据包\n  \n\n8.域名解析工具：dig9.网络请求：curl五.开发及调试1.编辑器：vim2.编译器：gcc和g++C程序的编译过程\n使用方法1234567891011121314151617gcc/g++ [选项] 源文件选项：    -E：让编译器在预处理之后停止，不进行后续编译过程，得到.i文件    -S：让编译器在编译之后停止 ，不进行后续过程，得到.s文件    -c：生成机器码即二进制.o文件    -o：指定目标文件名    -g：在编译的时候生成调试信息    -Wall：生成所有警告信息    -I 目录：指定头文件的查找目录    生成动态链接库：        1. gcc/g++ -c -fPIC 源文件 -o 目标文件名        2. gcc -shared 目标文件名 -o 动态链接库名.so    生成静态链接库：        1. gcc/g++ -c 源文件 -o 目标文件名        2. ar -crv 静态链接库名.a 目标文件名    -l库名 -L 目录：引入链接库，-L指定查找该库的目录。如-lm表示引入libm.so\n\n3.调试工具：gdb使用方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#第一步：得到可执行文件gcc/g++ -o 可执行文件 -g 源文件#第二步：启动gdbgdb #启动gdb#第三步：执行gdb命令进行调试(gdb) gdb命令gdb命令：    file 可执行文件：导入需要调试的文件    r：运行程序    q：退出gdb    b：设置断点        b 行号        b 函数名称        b *函数名        b *代码地址        b 编号    c：继续执行，直到下一断点或程序结束    s：执行一行代码，如果此行代码有函数调用则进入函数    n：执行一行代码，如果此行代码有函数调用，不进入函数，直接执行函数    i(info) 子命令：查看某些信息（只输入info或i可以查看有哪些子命令）        info thread：查看进程的所有线程，会显示每个线程的序号（1~n）    thread 线程序号：切换到相应的线程（线程序号可以由info thread得到）    f(frame) 函数栈帧号：切换到相应的函数栈帧（函数栈帧号可以由where等命令得到）    list：查看源码        list 行号：查看指定行号附近的源码        list 函数：查看指定函数附近的源码        list 文件:行号：查看指定文件中指定行附近的代码    where：查看当前位置    p(print) /格式 表达式        格式：            x：按十六进制格式显示变量            d：按十进制格式显示变量            u：按十六进制格式显示无符号整形            o：按八进制格式显示变量            t：按二进制格式显示变量            a：按十六进制格式显示变量            c：按字符格式显示变量            f：按浮点数格式显示变量        表达式中可用的操作符：            @：一个和数组有关的操作符，左边是起始地址，右边是长度（p *arr@3）            ::：指定一个在文件或是函数中的变量（p &#x27;f2.c&#x27;::x）            &#123;&lt;type&gt;&#125;&lt;addr&gt;：一个指向内存&lt;addr&gt;的类型为type的一个对象    x(examine) &lt;n/f/u&gt; &lt;addr&gt;：查看内存        n：正整数，表示需要显示的内存单元个数        f：显示的格式（格式字母同上面的print）        u：每个单元的字节数            b：1字节            h：2字节            w：4字节（默认）            g：8字节\n\n4.查看依赖库：ldd5.二进制文件分析：objdump6.ELF文件格式分析：readelf7.跟踪进程中系统调用：strace8.跟踪进程栈：pstack9.进程内存映射：pmap六.其他1.终止进程：kill2.修改文件权限：chmod\nw权限不具有删除文件的能力\n目录的x权限表示能否进入目录\n\n使用方法12345chmod [选项] [u|g|o|a][+|-][r|w|x] 文件或目录chmod [选项] 权限的数字表示 文件或目录选项：    -R：递归式的修改\n\n3.创建链接：ln4.显示文件尾：tail5.版本控制：git6.设置别名：alias","slug":"Linux常用命令","date":"2024-09-09T14:06:25.408Z","categories_index":"Linux","tags_index":"常用命令","author_index":"神秘奇男子"},{"id":"b7eae51efb7dc6d81a7837b0d6a16f52","title":"Git的简单归纳","content":"Git的简单归纳\n\n\n\n\n\n\n\n\n内容修改自github博主arkingc，持续修改补充中\n\n\n\n一.git配置\n1.配置git用户名和邮箱\n\n\n二.仓库\n1.创建git仓库\n2.查看仓库状态\n3.远程仓库\n4.协同工作\n5.使用GitHub\n\n\n三.版本控制\n1.添加或删除修改\n2.提交版本\n3.文件删除\n4.工作现场保存与恢复\n5.改动查询\n6.版本回退\n7.查看历史提交\n\n\n四.分支管理\n1.创建与合并分支\n2.分支合并冲突\n3.分支管理策略\n\n\n\n\n\n\n\n一.git配置优先级：--local &gt; --global &gt; --system\n\n\n\n\n\n\n\n\n\n用了--global这个参数，表示你这台机器上所有的Git仓库都会使用这个配置\n1.配置git用户名和邮箱1234git config --global user.name        # 查看git config --global user.name 用户名  # 修改git config --global user.email       # 查看git config --global user.email 邮箱   # 修改\n\n\n\n二.仓库1.创建git仓库12git init 仓库名  #创建一个git仓库git init        #将一个项目转化为使用git管理（创建.git目录）\n\n示例：\n\n目录结构：\n12345678910project   |------.git            |--------branches            |--------config        #仓库的配置文件            |--------description            |--------HEAD            |--------hooks            |--------info            |--------objects            |--------refs\n\n\n\n\n\n\n\n\n\n\n隐藏目录.git不算工作区，而是Git的版本库\n2.查看仓库状态1git status\n\n\n\n3.远程仓库\n\n\n\n\n\n\n\n\n最早，肯定只有一台机器有一个原始版本库，此后，别的机器可以“克隆”这个原始版本库，而且每台机器的版本库其实都是一样的，并没有主次之分\n实际情况往往是这样，找一台电脑充当服务器的角色，每天24小时开机，其他每个人都从这个“服务器”仓库克隆一份到自己的电脑上，并且各自把各自的提交推送到服务器仓库里，也从服务器仓库中拉取别人的提交\nGitHub就是提供Git仓库托管服务的，所以，只要注册一个GitHub账号，就可以免费获得Git远程仓库，即Github为我们的git仓库提供了一个远程仓库，有了这个远程仓库，妈妈再也不用担心我的硬盘了\n1）为本地与GitHub的通信配置ssh本地git仓库和GitHub上的远程仓库之间的传输是通过SSH加密的，所以，需要一点设置：\n\n创建ssh key： 1ssh-keygen -t rsa -C &quot;youremail@example.com&quot;\n登录你的GitHub帐号，Settings -&gt; SSH and GPG keys -&gt; new SSH key ，将id_rsa.pub的内容复制进去\n\n\n\n\n\n\n\n\n\n\n为什么GitHub需要SSH Key呢？因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送\n2）让本地git仓库和远程仓库同步\n\n\n\n\n\n\n\n\n在有了本地git仓库后，还需创建对应的远程仓库\n\n在GitHub上创建远程仓库（如果已有则省略）\n为本地仓库设置远程仓库信息（如果同时需要为本地仓库添加多个远程仓库（如果github+码云），则可以将origin分别换成github和gitee，推送操作时也要修改origin。添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库） 1git remote add origin https://github.com/用户名/仓库名\n\n删除本地仓库的远程仓库信息：git remote remove origin\n修改远端地址：git remote set-url 新地址\n查看远程仓库信息：git remote -v\n\n\n将本地git仓库push到远程仓库 1234# 由于远程库是空的，我们第一次推送master分支时，加上了-u参数,Git不但会把本地的# master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master# 分支关联起来，在以后的推送或者拉取时就可以简化命令git push [-u] origin 分支名\n\n并不是一定要把本地分支往远程推送。哪些分支需要推送、哪些不需要呢？\n\nmaster：主分支，要时刻与远程同步\ndev：开发分支，团队所有成员都需要在上面工作，所有也需要与远程同步\nbug：只用于在本地修复bug，就没必要推送到远程了，除非老板要看看你每周修复了几个bug\n\n4.协同工作拉取分支：\n1git pull\n\ngit clone时，默认情况下只能看到本地的master分支。如果要在dev分支上开发，就必须创建远程origin的dev分支到本地，可以使用如下命令创建本地dev分支：\n1git checkout -b dev\n\n将本地dev分支与远程origin/dev分支关联起来：\n1git branch --set-upstream dev origin/dev\n\n\n\n5.使用GitHubBootstrap的官方仓库twbs&#x2F;bootstrap、你在GitHub上克隆的仓库my&#x2F;bootstrap，以及你自己克隆到本地电脑的仓库，他们的关系就像下图显示的那样：\n\n如果你想修复bootstrap的一个bug，或者新增一个功能，立刻就可以开始干活，干完后，往自己的仓库推送\n如果你希望bootstrap的官方库能接受你的修改，你就可以在GitHub上发起一个pull request。当然，对方是否接受你的pull request就不一定了\n\n\n\n\n三.版本控制隐藏目录.git不算工作区，而是Git的版本库。版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区。还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD\n\n1.添加或删除修改将修改添加到暂存区：\n1git add 文件/目录\n\n从暂存区删除修改：\n1git rm --cached 文件/目录\n\n以下命令可以将暂存区的修改重置，暂存区的改变会被移除到工作区：\n1git reset HEAD [文件名]\n\n以下命令可以丢弃工作区的修改：\n1git checkout -- [文件名]\n\n如果刚对一个文件进行了编辑，可以撤销文件的改变，回到编辑开始。命令其实起到“一键恢复”的作用，还可用于“误删恢复”。可以在 git reset HEAD [文件名] 后使用\n2.提交版本如果修改了readme.txt，添加了文件LICENSE，并将2者添加到暂存区后，暂存区的状态就变成这样：\n\n使用commit提交修改，实际上就是把暂存区的所有内容提交到当前分支：\n1git commit -m &#x27;信息&#x27;\n\n\n\n\n\n\n\n\n\n\n\ncommit相当于游戏里面一次存档。对应一个版本\n3.文件删除rm做出的删除不会被暂存，git rm做出的改变会被暂存。如果使用rm删除掉，能使用git rm来暂存。git rm不在意文件已经不存在了\n\n删除(暂存)单个文件\n  1git rm\n\n删除(暂存)多个文件（一般情况下，更可能是对大量文件进行管理。可能同时会删除很多文件，不可能使用git rm一个个删除）\n  12# 它会变量当前目录，将所有删除暂存git add -u .\n\n如果有文件被误删，可以使用git checkout -- 文件名恢复\n4.工作现场保存与恢复有时候在修复bug或某项任务还未完成，但是需要紧急处理另外一个问题。此时可以先保存工作现场，当问题处理完成后，再恢复bug或任务的进度\n\n保存工作现场：git stash\n查看保存的工作现场：git stash list\n恢复工作现场：git stash apply\n删除stash内容：git stash drop\n恢复工作现场并删除stash内容（相当于上面2步合并）：git stash pop\n\n5.改动查询1234567git diff [选项]           # 查看工作区中的修改git diff [选项] --staged   # 查看已添加到暂存区的修改git diff [选项] HEAD       # 查看当前所有未提交的修改选项：    --color-words： 颜色    --stat：        不显示具体修改，只显示修改了的文件\n\n6.版本回退123456git reset --hard 版本ID/HEAD形式的版本git reset --hard HEAD      # 当前版本git reset --hard HEAD^     # 上一个版本git reset --hard HEAD^^    # 上上个版本git reset --hard HEAD~n    # 前n个版本\n\n如果回到过去的版本，想要回到原来新的版本：\n\n如果终端未关，可以找到新版本的id，通过上述命令回去新版本\n如果终端已关，git reflog查看版本，再通过上述命令回去新版本\n\n7.查看历史提交1234567git log [选项]选项：    --online：只显示提交提示信息    --stat：添加每次提交包含的文件信息    --path：查看每次提交改变的内容    --graph\n\n加文件名可以显示具体文件相关的所有提交信息\n\n\n四.分支管理1.创建与合并分支每次commit相当于一次存档，对应一个版本。Git都把它们串成一条时间线，这条时间线就是一个分支。master就是主分支。HEAD指向当前分支，而master指向主分支的最近提交。每次提交，master分支都会向前移动一步\n当创建一个分支时，如dev，Git创建一个指针dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上：\n  \n\n从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变：\n  \n\n假如我们在dev上的工作完成了，就可以把dev合并到master上。最简单的方法，就是直接把master指向dev的当前提交，就完成了合并：\n  \n\n合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支：\n  \n\n上面的合并使用的是Fast forward。这种模式下，删除分支后，会丢掉分支信息。如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的提交，这样，从分支历史上就可以看出分支信息。通过在git merge命令中使用--no-ff选项禁用Fast forward模式。比如在合并dev时：\n1git merge --no-ff -m &quot;merge with no-ff&quot; dev\n\n由于会生成一个新的提交，所以需要使用-m指明新提交的信息。此时分支情况如下：\n  \n\n相关命令如下：\n\n(创建分支并)切换到新分支：git checkout -b 新分支\n创建分支：git branch 新分支\n切换分支：git checkout 欲切换到的分支\n查看当前分支：git branch\n合并某分支到当前分支：git merge 欲合并到当前分支的分支\n查看历史分支情况：git log --graph --pretty=oneline --abbrev-commit\n删除未合并的分支：git branch -D 分支\n\n2.分支合并冲突如果两个分支修改了同一文件，合并时会发生冲突。比如master分支和feature1分支都修改了readme.txt文件，各自都有新的提交：\n  \n\n这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突。此时readme.txt文件会变成如下形式：\n123456789Git is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage.Git tracks changes of files.&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADCreating a new branch is quick &amp; simple.=======Creating a new branch is quick AND simple.&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1\n\nGit用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，此时需要手动修改后保存。然后再使用git commit进行一次提交。分支会变成如下：\n  \n\n3.分支管理策略在实际开发中，我们应该按照几个基本原则进行分支管理\n首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活\n干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本\n你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了\n所以，团队合作的分支看起来就像这样：\n  \n\n当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin\n要查看远程库的信息，用git remote：\n12$ git remoteorigin\n\n或者，用git remote -v显示更详细的信息：\n123$ git remote -vorigin  git@github.com:michaelliao/learngit.git (fetch)origin  git@github.com:michaelliao/learngit.git (push)\n\n上面显示了可以抓取和推送的origin的地址。如果没有推送权限，就看不到push的地址\n推送分支1git push origin 欲推送的分支\n\n\nmaster分支是主分支，因此要时刻与远程同步\ndev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步\nbug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug\nfeature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发\n\n","slug":"Git简介","date":"2024-09-09T13:29:06.476Z","categories_index":"Git","tags_index":"git简介,git简单使用","author_index":"神秘奇男子"},{"id":"3c9c3f4226248e23e6c72e4ac83d74c5","title":"简单的水果分类识别","content":"任务一：水果分类识别​\t首先我先描述一下我的大体实现思路：\n整体思路流程\n特征提取：从图像中提取两类特征（边界特征和纹理特征），用于描述水果的形状和表面纹理。\n\n数据处理：读取数据目录中的图像，提取特征并准备数据集。\n\n模型训练：使用提取的特征数据训练一个逻辑回归模型。\n\n单个图像预测：使用训练好的模型对单个图像进行预测，并输出预测结果。\n\n\n\n\n\n\n\n\n\nWARNING\n其中边界特征利用Canny算法提取，然后在图像内部选择感兴趣（ROI）区域进行特征提取，最后都要归一化处理。\n\n1.1 特征提取之边界特征提取​\t通过搜寻相关资料，利用canny进行提取边缘的步骤如下(参考下方代码)：\n1.灰度转换：将输入的彩色图像转换为灰度图像。2.高斯模糊：对灰度图像进行高斯模糊处理以减少噪声。3.Canny 边缘检测：使用 Canny 算法提取图像的边缘。4.轮廓检测：找到图像中的所有轮廓。5.计算线段长度：遍历每个轮廓，计算相邻点之间的距离。6.归一化特征：对所有线段长度进行归一化处理。7.截取特征向量：只保留前 10 个特征值。\n\n点击这里查看边界特征提取代码\n123456789101112131415161718def extract_shape_features(image):    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)    blurred = cv2.GaussianBlur(gray, (5, 5), 0)    edges = cv2.Canny(blurred, 50, 150)    contours, _ = cv2.findContours(edges, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)    shape_features = []    for contour in contours:        for i in range(len(contour) - 1):            length = cv2.norm(contour[i] - contour[i + 1])            shape_features.append(length)    shape_features = np.array(shape_features)    if shape_features.size &gt; 0:        shape_features = shape_features / np.linalg.norm(shape_features)    else:        shape_features = np.zeros(10)    return shape_features[:10]\n\n\n1.2 特征提取之纹理特征提取​\t经查询相关资料，纹理特征提取步骤如下（参考下面代码）：\n\n灰度转换：将输入的彩色图像转换为灰度图像。\n确定感兴趣区域（ROI）：在图像中心选取一个较小的区域作为纹理分析的对象。\n计算统计特征：计算选定区域的均值和标准差。\n归一化特征：对计算出的特征向量进行归一化处理。\n\n\n点击这里查看纹理特征提取代码\n12345678910111213def extract_texture_features(image):    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)    h, w = gray.shape    x, y = w // 2, h // 2    roi = gray[max(0, y - 5):min(h, y + 5), max(0, x - 5):min(w, x + 5)]    mean = np.mean(roi)    std_dev = np.std(roi)    texture_features = np.array([mean, std_dev])    if np.linalg.norm(texture_features) &gt; 0:        texture_features = texture_features / np.linalg.norm(texture_features)    return texture_features\n\n\n2 数据处理​\t训练的数据集大部分来自百度飞桨的公开数据库，参考链接：https://aistudio.baidu.com/datasetdetail/90377，\n​\t还有部分来自谷歌图片上手动下载保存，为了确保特征提取准确、模型预测更精准，我删除了大量较复杂的图片，只保留了简单的、具有单个水果、特征明显的图片，因此最后的图片数量不多。\n​\t为了使数据多样化、尽可能避免过拟合现象，我搜寻了一些简单的数据增强的方法，基于现有的图片数据增生了一些图片。如下面图片既包括搜集到的数据，也包括增生的数据。\n\n准备完了数据，我们开始利用之前的方法提取特征：\n\n路径和标签初始化：初始化两个列表 image_paths 和 labels 用于存储图像路径和标签。\n标签映射：定义一个字典 label_map 将水果类型映射为整数标签。\n读取图像并提取特征：读取每张图像，提取形状特征和纹理特征，并将它们合并为一个特征向量。\n返回特征矩阵和标签数组：将特征列表转换为 NumPy 数组，并返回特征矩阵和标签数组。\n\n\n点击这里查看数据处理部分的代码\n123456789101112131415161718192021222324252627282930313233343536# 数据准备def prepare_data(base_dir):    image_paths = []    labels = []    label_map = &#123;&#x27;apple&#x27;: 0, &#x27;banana&#x27;: 1, &#x27;orange&#x27;: 2&#125;    for fruit_type, label in label_map.items():        fruit_dir = os.path.join(base_dir, fruit_type)        if os.path.isdir(fruit_dir):            for filename in os.listdir(fruit_dir):                if filename.lower().endswith((&#x27;.png&#x27;, &#x27;.jpg&#x27;, &#x27;.jpeg&#x27;)):                    image_paths.append(os.path.join(fruit_dir, filename))                    labels.append(label)    X = []    y = np.array(labels)    for path in image_paths:        image = cv2.imread(path)        if image is None:            print(f&quot;警告：无法读取图像 &#123;path&#125;，请检查文件路径。&quot;)            continue        shape_features = extract_shape_features(image)        texture_features = extract_texture_features(image)        features = np.hstack((shape_features, texture_features))        X.append(features)    return np.array(X), y# 使用 JPEGImages 目录进行数据准备base_dir = &#x27;JPEGImages&#x27;X, y = prepare_data(base_dir)# 归一化特征scaler = StandardScaler()X = scaler.fit_transform(X)\n\n\n\n3 模型训练模型训练大致分以下几步：\n\n数据划分：将数据划分为80%训练集和20%测试集，以确保模型在未知数据上的泛化能力。\n\n模型创建和训练：创建逻辑回归模型，并使用训练集进行训练。逻辑回归是一种常用的分类算法，\n适用于多分类任务。\n\n模型预测：使用训练好的模型对测试集进行预测，得到预测标签。\n\n准确率计算：计算预测标签与真实标签之间的准确率，评估模型性能。\n\n\n\n\n\n\n\n\n\n\n\n（经检验运行后发现准确率不是非常理想，我猜测既因数据集较少、泛化能力不够，也因这类方法在分类水果上有一定的局限性，是特征提取方法存在的局限）\n\n点击这里查看上述步骤的代码\n1234567891011121314# 划分训练集和测试集X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)# 创建逻辑回归模型并训练model = LogisticRegression(max_iter=1000)model.fit(X_train, y_train)# 模型预测y_pred = model.predict(X_test)# 计算准确率accuracy = accuracy_score(y_test, y_pred)#print(f&quot;模型准确率: &#123;accuracy:.2f&#125;&quot;)\n\n\n\n4 单个图像预测最后我们可以利用之前训练好的模型进行图片预测,可以将其封装成一个函数，函数实现步骤如下：\n\n读取图像：使用 cv2.imread 读取待测试的图像。\n特征提取：提取图像的形状特征和纹理特征。\n合并特征：将形状特征和纹理特征合并为一个特征向量，并重塑为 (1, -1) 形状。\n特征缩放：使用预先训练好的 scaler 对特征进行缩放处理。\n模型预测：使用训练好的模型对缩放后的特征进行预测。\n\n\n点击这里查看图片预测函数\n12345678910111213# 单个图像分类示例def predict_image(image_path):    image = cv2.imread(image_path)    if image is None:        print(f&quot;无法读取图像 &#123;image_path&#125;，请检查路径。&quot;)        return None    shape_features = extract_shape_features(image)    texture_features = extract_texture_features(image)    features = np.hstack((shape_features, texture_features)).reshape(1, -1)    features = scaler.transform(features)    prediction = model.predict(features)    return prediction[0]\n\n\n\n最后将要测试的图片的路径修改入代码之中，运行之后即可看到预测的结果，结果如下\n\n5 完结撒花\n","slug":"水果分类识别","date":"2024-09-06T13:41:30.558Z","categories_index":"机器学习","tags_index":"逻辑回归,水果分类,计算机视觉","author_index":"神秘奇男子"},{"id":"dc76bdb116b22b7d8e614c5e499a6c3f","title":"Haar 特征分类器实现人脸识别","content":"基于OpenCV 的 Haar 特征分类器实现人脸检测与显示在计算机视觉领域，人脸检测是非常基础而且常用的技术，最近刚好在学计算机视觉的相关知识，学到人脸识别时，感到比较有趣\n于是简单写一下我的实现过程。[](￣▽￣)*\n本文将展示如何使用 OpenCV 和 Python 来实现简单的人脸检测，并使用 Matplotlib 对结果进行可视化。\n1. 环境配置首先，我们需要确保已安装必要的库：\n1pip install opencv-python matplotlib\n\n2. 代码实现代码分为几个关键部分：图像的读取与处理、人脸检测、绘制矩形框以及结果显示。\n2.1. 导入所需的库我们首先导入 OpenCV 和 Matplotlib，用于图像处理和结果显示。\n12import cv2import matplotlib.pyplot as plt\n\n2.2. 定义显示图像的函数为了更好地展示图像，我定义了一个 show_img 函数，将 BGR 格式的图像转换为 RGB 格式，并用 Matplotlib 显示出来。\n123456def show_img(img, title, pos):    img_RGB = img[:, :, ::-1]  # BGR 转 RGB    plt.subplot(2, 2, pos)    plt.title(title)    plt.imshow(img_RGB)    plt.xticks([])  # 隐藏 x 轴刻度\n\n2.3. 绘制人脸矩形框的函数plot_rectangle 函数用于在人脸检测结果中绘制矩形框：\n1234def plot_rectangle(img, faces):    for (x, y, w, h) in faces:        cv2.rectangle(img, (x, y), (x + w, y + h), (0, 255, 255), 2)  # 绘制黄色矩形框    return img\n\n2.4. 主程序主程序中，我们加载图像、转换为灰度图，并使用 OpenCV 的 Haar 特征分类器进行人脸检测。最后，绘制检测到的人脸并显示图像。\n123456789101112def main():    image = cv2.imread(&quot;../resources/tg009.jpg&quot;)  # 读取图像    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)  # 转为灰度图    face_cascade = cv2.CascadeClassifier(&quot;haarcascade_frontalface_alt.xml&quot;)  # 加载分类器    faces = face_cascade.detectMultiScale(gray)  # 人脸检测    face_alt2 = plot_rectangle(image.copy(), faces)  # 绘制矩形框    plt.figure(figsize=(10, 10))    plt.suptitle(&quot;Face Detection&quot;, fontsize=14, fontweight=&quot;bold&quot;)    show_img(face_alt2, &quot;face_alt2&quot;, 1)    plt.show()\n\n\n\n\n\n\n\n\n\n\n\n\nWARNING\n上面代码值得注意的是,haarcascade_frontalface_alt2.xml分类器我是从opencv源码里面复制的，  还有其他几种分类器可以用:\n\n\n代码的运行效果如图所示：检测到的人脸区域被黄色矩形框标出，结果被显示在 Matplotlib 窗口中。\n\n3. 运行结果分析可以看到，最后效果并不是那么好，因为这个算法是比较老的了，现在利用深度学习的算法能做到非常精准，因此本方法了解一下就行。\n4. 结论本篇文章展示了如何使用 Python 和 OpenCV 实现人脸检测，以及如何利用 Matplotlib 对结果进行可视化。在实际项目中，人脸检测可以被应用于多种场景，如监控系统、智能门禁和人脸识别考勤等。\n","slug":"基于OpenCV 的 Haar 特征分类器实现人脸检测与显示","date":"2024-08-24T06:37:38.807Z","categories_index":"计算机视觉","tags_index":"OpenCV,人脸识别","author_index":"神秘奇男子"},{"id":"3ceded50fe0dd372bcf8c1a5f8350431","title":"Welcome to AUG's Blog","content":"\nHello,你们好！（づ￣3￣）づ╭❤️～欢迎来到我的博客我会不定期持续更新文章,欢迎大家批评指正","slug":"hello-world","date":"2024-08-21T13:16:45.064Z","categories_index":"","tags_index":"博客简介","author_index":"神秘奇男子"}]