[{"id":"3c9c3f4226248e23e6c72e4ac83d74c5","title":"简单的水果分类识别","content":"任务一：水果分类识别​\t首先我先描述一下我的大体实现思路：\n整体思路流程\n特征提取：从图像中提取两类特征（边界特征和纹理特征），用于描述水果的形状和表面纹理。\n\n\n\n\n\n\n\n\n\n[!NOTE]\n其中边界特征利用Canny算法提取，然后在图像内部选择感兴趣（ROI）区域进行特征提取，最后都要归一化处理。\n\n数据准备：读取数据目录中的图像，提取特征并准备数据集。\n\n模型训练：使用提取的特征数据训练一个逻辑回归模型。\n\n单个图像预测：使用训练好的模型对单个图像进行预测，并输出预测结果。\n\n\n特征提取之边界特征提取​\t通过搜寻相关资料，利用canny进行提取边缘的步骤如下(参考下方代码)：\n1.灰度转换：将输入的彩色图像转换为灰度图像。2.高斯模糊：对灰度图像进行高斯模糊处理以减少噪声。3.Canny 边缘检测：使用 Canny 算法提取图像的边缘。4.轮廓检测：找到图像中的所有轮廓。5.计算线段长度：遍历每个轮廓，计算相邻点之间的距离。6.归一化特征：对所有线段长度进行归一化处理。7.截取特征向量：只保留前 10 个特征值。\n123456789101112131415161718def extract_shape_features(image):    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)    blurred = cv2.GaussianBlur(gray, (5, 5), 0)    edges = cv2.Canny(blurred, 50, 150)    contours, _ = cv2.findContours(edges, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)    shape_features = []    for contour in contours:        for i in range(len(contour) - 1):            length = cv2.norm(contour[i] - contour[i + 1])            shape_features.append(length)    shape_features = np.array(shape_features)    if shape_features.size &gt; 0:        shape_features = shape_features / np.linalg.norm(shape_features)    else:        shape_features = np.zeros(10)    return shape_features[:10]\n\n\n\n\n\n特征提取之纹理特征提取​\t经查询相关资料，纹理特征提取步骤如下（参考下面代码）：\n\n灰度转换：将输入的彩色图像转换为灰度图像。\n确定感兴趣区域（ROI）：在图像中心选取一个较小的区域作为纹理分析的对象。\n计算统计特征：计算选定区域的均值和标准差。\n归一化特征：对计算出的特征向量进行归一化处理。\n\n12345678910111213def extract_texture_features(image):    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)    h, w = gray.shape    x, y = w // 2, h // 2    roi = gray[max(0, y - 5):min(h, y + 5), max(0, x - 5):min(w, x + 5)]    mean = np.mean(roi)    std_dev = np.std(roi)    texture_features = np.array([mean, std_dev])    if np.linalg.norm(texture_features) &gt; 0:        texture_features = texture_features / np.linalg.norm(texture_features)    return texture_features\n\n\n\n数据准备​\t训练的数据集大部分来自百度飞桨的公开数据库，参考链接：https://aistudio.baidu.com/datasetdetail/90377，\n​\t还有部分来自谷歌图片上手动下载保存，为了确保特征提取准确、模型预测更精准，我删除了大量较复杂的图片，只保留了简单的、具有单个水果、特征明显的图片，因此最后的图片数量不多。\n​\t为了使数据多样化、尽可能避免过拟合现象，我搜寻了一些简单的数据增强的方法，基于现有的图片数据增生了一些图片。\n\n","slug":"水果分类识别","date":"2024-09-06T13:41:30.558Z","categories_index":"机器学习","tags_index":"逻辑回归,水果分类,计算机视觉","author_index":"神秘奇男子"},{"id":"dc76bdb116b22b7d8e614c5e499a6c3f","title":"Haar 特征分类器实现人脸识别","content":"基于OpenCV 的 Haar 特征分类器实现人脸检测与显示在计算机视觉领域，人脸检测是非常基础而且常用的技术，最近刚好在学计算机视觉的相关知识，学到人脸识别时，感到比较有趣\n于是简单写一下我的实现过程。[](￣▽￣)*\n本文将展示如何使用 OpenCV 和 Python 来实现简单的人脸检测，并使用 Matplotlib 对结果进行可视化。\n1. 环境配置首先，我们需要确保已安装必要的库：\n1pip install opencv-python matplotlib\n\n2. 代码实现代码分为几个关键部分：图像的读取与处理、人脸检测、绘制矩形框以及结果显示。\n2.1. 导入所需的库我们首先导入 OpenCV 和 Matplotlib，用于图像处理和结果显示。\n12import cv2import matplotlib.pyplot as plt\n\n2.2. 定义显示图像的函数为了更好地展示图像，我定义了一个 show_img 函数，将 BGR 格式的图像转换为 RGB 格式，并用 Matplotlib 显示出来。\n123456def show_img(img, title, pos):    img_RGB = img[:, :, ::-1]  # BGR 转 RGB    plt.subplot(2, 2, pos)    plt.title(title)    plt.imshow(img_RGB)    plt.xticks([])  # 隐藏 x 轴刻度\n\n2.3. 绘制人脸矩形框的函数plot_rectangle 函数用于在人脸检测结果中绘制矩形框：\n1234def plot_rectangle(img, faces):    for (x, y, w, h) in faces:        cv2.rectangle(img, (x, y), (x + w, y + h), (0, 255, 255), 2)  # 绘制黄色矩形框    return img\n\n2.4. 主程序主程序中，我们加载图像、转换为灰度图，并使用 OpenCV 的 Haar 特征分类器进行人脸检测。最后，绘制检测到的人脸并显示图像。\n123456789101112def main():    image = cv2.imread(&quot;../resources/tg009.jpg&quot;)  # 读取图像    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)  # 转为灰度图    face_cascade = cv2.CascadeClassifier(&quot;haarcascade_frontalface_alt.xml&quot;)  # 加载分类器    faces = face_cascade.detectMultiScale(gray)  # 人脸检测    face_alt2 = plot_rectangle(image.copy(), faces)  # 绘制矩形框    plt.figure(figsize=(10, 10))    plt.suptitle(&quot;Face Detection&quot;, fontsize=14, fontweight=&quot;bold&quot;)    show_img(face_alt2, &quot;face_alt2&quot;, 1)    plt.show()\n\n\n\n\n\n\n\n\n\n\n\n\nWARNING\n上面代码值得注意的是,haarcascade_frontalface_alt2.xml分类器我是从opencv源码里面复制的，  还有其他几种分类器可以用:\n\n\n代码的运行效果如图所示：检测到的人脸区域被黄色矩形框标出，结果被显示在 Matplotlib 窗口中。\n\n3. 运行结果分析可以看到，最后效果并不是那么好，因为这个算法是比较老的了，现在利用深度学习的算法能做到非常精准，因此本方法了解一下就行。\n4. 结论本篇文章展示了如何使用 Python 和 OpenCV 实现人脸检测，以及如何利用 Matplotlib 对结果进行可视化。在实际项目中，人脸检测可以被应用于多种场景，如监控系统、智能门禁和人脸识别考勤等。\n","slug":"基于OpenCV 的 Haar 特征分类器实现人脸检测与显示","date":"2024-08-24T06:37:38.807Z","categories_index":"计算机视觉","tags_index":"OpenCV,人脸识别","author_index":"神秘奇男子"},{"id":"3ceded50fe0dd372bcf8c1a5f8350431","title":"Welcome to AUG's Blog","content":"\nHello,你们好！（づ￣3￣）づ╭❤️～欢迎来到我的博客我会不定期持续更新文章,欢迎大家批评指正","slug":"hello-world","date":"2024-08-21T13:16:45.064Z","categories_index":"","tags_index":"博客简介","author_index":"神秘奇男子"}]